<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<title>403 — ACCESS DENIED</title>

<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono&display=swap" rel="stylesheet">
<link rel="stylesheet" href="style.css?v=1">
</head>

<body>
<canvas id="matrix"></canvas>

<div id="introScreen" class="intro-screen">
  <div class="region-select">
    <button class="region-btn" data-region="world">WORLD</button>
    <button class="region-btn" data-region="nl_only">NETHERLANDS</button>
    <button class="region-btn" data-region="europe">EUROPE</button>
    <button class="region-btn" data-region="na">NORTH-AMERICA</button>
    <button class="region-btn" data-region="sa">SOUTH-AMERICA</button>
    <button class="region-btn" data-region="africa">AFRICA</button>
    <button class="region-btn" data-region="asia_pacific">ASIA-PACIFIC</button>
    <button class="region-btn ghost-btn" data-region="more">MORE THEMES (soon)</button>
  </div>
</div>

<div class="status">403 — ACCESS DENIED</div>
<button class="back-button back-inline" id="backBtn"></button>

<div class="terminal">
  <div class="terminal-header">
    <div class="window-buttons">
      <span class="close"></span>
      <span class="minimize"></span>
      <span class="maximize"></span>
    </div>
    <div class="terminal-title" id="terminalTitle"></div>
  </div>
  <div class="terminal-body" id="terminalBody">
  <div class="terminal-output" id="terminalOutput"></div>
</div>

</div>

<script>
(async () => {

let hasBootedOnce = false;
let CONFIG = {};
let ACTIVE_REGION = "world";

let WORLD_SEED;
let rand;

function mulberry32(a) {
  return function() {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}

function reseedWorld() {
  const seedArray = new Uint32Array(1);
  crypto.getRandomValues(seedArray);
  WORLD_SEED = seedArray[0];
  rand = mulberry32(WORLD_SEED);
}

reseedWorld();

/* ================= CONFIG LOAD (MODULAR) ================= */

const [
  TRAFFIC,
  IDENTITY,
  THEMES,
  POLICY,
  UI,
  VISUALS
] = await Promise.all([
  fetch("traffic.txt",  { cache: "no-store" }).then(r => r.json()),
  fetch("identity.txt", { cache: "no-store" }).then(r => r.json()),
  fetch("themes.txt",   { cache: "no-store" }).then(r => r.json()),
  fetch("policy.txt",   { cache: "no-store" }).then(r => r.json()),
  fetch("ui.txt",       { cache: "no-store" }).then(r => r.json()),
  fetch("visuals.txt",  { cache: "no-store" }).then(r => r.json())
]);

CONFIG = {
  ...TRAFFIC,
  ...IDENTITY,
  ...THEMES,
  ...POLICY,
  ...UI,
  ...VISUALS
};

if (!CONFIG.GROUP_WEIGHTS) {
  throw new Error("Config missing GROUP_WEIGHTS");
}

document.body.style.overflow = "auto";

/* ================= CONFIG BINDINGS ================= */

const REGION_MAP = {
  world: null, // alles

  europe: [
    "de","fr","nl","it","es","pl","se","no","fi","ch","at","be",
    "pt","ro","bg","hu","gr","ua","ru","frl","sm"
  ],
    
    nl_only: ["nl"],

  na: ["us","ca"],

  sa: ["br","co","ve","jm"],

  africa: ["za","ng","gh","ke","ma","eg"],

  asia_pacific: [
    "in","pk","id","jp","kr","cn","il","tr"
  ]
};

const GEO_RESTRICTED_COUNTRIES =
  CONFIG.GEO_RESTRICTED_COUNTRIES || [];

const GROUP_WEIGHTS = CONFIG.GROUP_WEIGHTS;
const GROUP_LABELS  = CONFIG.GROUP_LABELS;
const UI_TEXT       = CONFIG.UI_TEXT;
const FLAG_THEMES   = CONFIG.FLAG_THEMES;
const WEIRD_NAMES   = CONFIG.WEIRD_NAMES;
const FIRST_NAMES   = CONFIG.FIRST_NAMES;
const LAST_NAMES    = CONFIG.LAST_NAMES;
const ASCII_FIGURES = CONFIG.ASCII_FIGURES;

const MIGRATION_ENABLED = CONFIG.MIGRATION_ENABLED ?? false;
const MIGRATION_CHANCE  = CONFIG.MIGRATION_CHANCE ?? 0;
const MIGRATION_MATRIX  = CONFIG.MIGRATION_MATRIX ?? {};

const POLICY_RESULTS = CONFIG.POLICY_RESULTS;
let POLICY_DECISION = null;

/* ================= POLICY ENGINE ================= */

function generatePolicyDecision() {

  // 1. Geo restriction op NETWORK level
  if (GEO_RESTRICTED_COUNTRIES.includes(NETWORK_GROUP)) {
    POLICY_DECISION = {
      status: "DENIED",
      reason: "geo restriction policy"
    };
    return;
  }

  // 2. Cross-border anomaly detectie
  if (SESSION.type === "datacenter") {
    POLICY_DECISION = {
      status: "DENIED",
      reason: "cross-border datacenter anomaly"
    };
    return;
  }

  // 3. Normale policy fallback
  const pool =
    POLICY_RESULTS[SESSION.type] ||
    POLICY_RESULTS["default"];

  POLICY_DECISION =
    pool[Math.floor(rand() * pool.length)];
}

/* ================= THEME ENGINE ================= */

function applyTheme(theme){
  const root = document.documentElement;

  const primary   = (theme.primary   || "#ffffff").toLowerCase();
  const secondary = (theme.secondary || "#ffffff").toLowerCase();

const tertiary = (theme.tertiary || "#ffffff").toLowerCase();
const uiTertiary = tertiary === "#000000" ? "#d0d0d0" : theme.tertiary;
root.style.setProperty("--ui-tertiary", uiTertiary);

  const uiPrimary =
    primary === "#000000" ? "#d0d0d0" : theme.primary;

  const uiSecondary =
    secondary === "#000000" ? "#d0d0d0" : theme.secondary;

  root.style.setProperty("--color-primary",   theme.primary);
  root.style.setProperty("--color-secondary", theme.secondary);
  root.style.setProperty("--color-tertiary",  theme.tertiary);
  root.style.setProperty("--color-accent",    theme.accent);
  root.style.setProperty("--color-error",     theme.error);

  root.style.setProperty("--ui-primary",   uiPrimary);
  root.style.setProperty("--ui-secondary", uiSecondary);

  const isBlackPrimary = primary === "#000000";

root.style.setProperty(
  "--btn-idle",
  isBlackPrimary ? theme.secondary : theme.primary
);

root.style.setProperty(
  "--btn-hover",
  isBlackPrimary ? theme.tertiary : theme.secondary
);

  currentPalette = [theme.primary, theme.secondary, theme.tertiary];

}

function getThemeForGroup(group){
  return FLAG_THEMES[group] || FLAG_THEMES["us"];
}

function getThemePalette() {
  const s = getComputedStyle(document.documentElement);
  return [
    s.getPropertyValue('--color-primary').trim(),
    s.getPropertyValue('--color-secondary').trim(),
    s.getPropertyValue('--color-tertiary').trim()
  ];
}

// ===== TITLE =====
let titleLogLines = [];

function generateTitleLogs() {

  const base = new Date();

  function pad(n){ return n.toString().padStart(2,"0"); }

  function format(d){
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ` +
           `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

titleLogLines = [];

const events = [
  `nginx: connection from ${VISITOR_IP} accepted`,
  `http: GET / → access control engaged`,
  `auth-module: request context received`,
  `authz: evaluation pending (rbac)`,];

for (let i = 0; i < events.length; i++) {
  const d = new Date(base.getTime() + (i * 1000));
  titleLogLines.push(`[${format(d)}] ${events[i]}`);
}
}

function getTitleText() {
  return `

${titleLogLines.join("\n")}
`;
}

// ===== LOG BUFFER  =====
const LOG_BUFFER_SIZE = 50;
const TAIL_LINES = 3;

let accessLogBuffer = []; // [{ text: "...", color: "#rrggbb" }]

function pushAccessLog(entry) {
  // entry = { text, color }
  accessLogBuffer.push(entry);
  if (accessLogBuffer.length > LOG_BUFFER_SIZE) {
    accessLogBuffer.shift();
  }
}

function getTailLines(n = TAIL_LINES) {
  return accessLogBuffer.slice(-n);
}

function uiPrimaryForGroup(group) {
  const theme = getThemeForGroup(group);
  const primary = (theme.primary || "#ffffff").toLowerCase();
  return theme.primary;
}

/* ================= MATRIX CORE ================= */

const STATES = {
    INTRO: -100,
    TITLE: -50,
    CURTAIN: 0,
    HASH: 50,
    BLACKOUT: 100,
    MATRIX_INTRO: 200,
    MATRIX_RUN: 300
};

let phase = STATES.INTRO;

const canvas = document.getElementById("matrix");
const ctx = canvas.getContext("2d");
const terminalElement = document.querySelector(".terminal");

const curtainChars = 
"abcdefghijklmnopqrstuvwxyz" +
"ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
"0123456789" +
"-_!+%$#@<>?/()*&";

const matrixChars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" +
"アイウエオカキクケコサシスセソタチツテトナニヌネノ" +
"ハヒフヘホマミムメモヤユヨラリルレロワヲン" +
"一二三四五六七八九十百千万零" +
"%$#@<>?/\\|[]{}()*&^";

let matrixFontSize  = window.innerWidth > 1800 ? 26 : 18;
let curtainFontSize = window.innerWidth > 1800 ? 20 : 14;

const trailSpacing = 20;

const CURTAIN_BLOCK_WIDTH = 12;
const CURTAIN_GAP_WIDTH   = 4.5;

/* gordijn spacing */
const curtainLineHeight    = curtainFontSize * 0.55;
const curtainColumnSpacing = curtainFontSize * 0.55;

let curtainColumns = 0;
let matrixColumns  = 0;

let drops = [];
let stacks = [];
let curtainGrid = [];
let curtainOffset = 0;
let blackoutStart = 0;

let speeds = [];
let maxLengths = [];
let spawnRates = [];
let drift = [];
let driftOffset = [];

let curtainSpeed = 260;
const acceleration = 700;
const curtainDepth = 4;

const curtainPauseDuration = 3000;
let curtainPauseStart = 0;
let currentPalette = [];

let CAPTURED_PASSWORD = null;

let lastTime = 0;
let forceSpike = 0;
let glitchActive = false;
let glitchBursts = 0;
let glitchEnd = 0;
let nextGlitchTime = 0;

let terminalGlitchActive = false;
let terminalGlitchEnd = 0;
let terminalNextGlitch = 0;
let terminalGlitchBursts = 0;
let terminalPhaseStarted = false;

let animationId = null;
let experienceStart = 0;
let pausedAt = 0;

let rollingSession = "";
let rollingStartTime = 0;
let rollingDone = false;
let rollingTriggered = false;

let finalSessionId = "";

let terminalStarted = false;
let terminalRunning = false;

async function startTerminalSequence() {
await resolveVisitorIP();
generateTitleLogs();


  HOST_LABEL = VISITOR_IP; // expliciet zetten

  document.getElementById("terminalTitle").textContent =
    `Terminal—${SITE_USER}@${VISITOR_IP}:~`;

  await new Promise(r => requestAnimationFrame(r));

  runTerminal();
}

const DOMAIN = "sterkbijziekte.nl";
const IP_ADDRESS = "2a02:2350:5:10f:804f:7eb:3c1c:131b";
let VISITOR_IP = "resolving...";
let HOST_LABEL = "resolving...";

let LAST_PROTOCOL = "HTTP/1.1";

/* ===== NORMALIZE + BLOCKLIST ===== */

function normalize(str){
  return str.toLowerCase().replace(/\s+/g, "");
}

/*block users*/
const BLOCKED = [
/*    normalize("voornaam.achternaam"), */
];

function generateSessionProfile() {

  const profiles = {
    residential: 60,
    datacenter: 25,
    scripted: 15
  };

  const type = pickFromWeights(profiles);

  const profile = { type };

  if (type === "residential") {
    profile.usernameStyle = "normal";
    profile.protocolBias = "http2";
    profile.latencyBase = 40;
    profile.requestPattern = "human";
  }

  if (type === "datacenter") {
    profile.usernameStyle = "mixed";
    profile.protocolBias = "http1";
    profile.latencyBase = 15;
    profile.requestPattern = "scan";
  }

  if (type === "scripted") {
    profile.usernameStyle = "weird-heavy";
    profile.protocolBias = "http1";
    profile.latencyBase = 5;
    profile.requestPattern = "burst";
  }

  return profile;
}

/* ===== WEIRD USERNAME ===== */

function generateWeirdUsername(group) {
  const weirdPool = WEIRD_NAMES[group] || [];
  if (!weirdPool.length) return null;

  const base = weirdPool[Math.floor(rand() * weirdPool.length)];
  let username = base;

  // Suffix verplicht: kies jaar vs digits
  const useYear = rand() < 0.60; // 60% jaar, 40% digits (tweak naar smaak)

  if (useYear) {
    const year = 1968 + Math.floor(rand() * 58); // 1968–2025-ish
    const sep = rand() < 0.50 ? "_" : ".";       
    username += sep + year;
  } else {
    const digits = (rand() < 0.65)
      ? (10 + Math.floor(rand() * 90))     // 10–99
      : Math.floor(rand() * 9999);         // 0–9998
    username += digits;
  }

  return { username: username.toLowerCase(), group };
}

function generateNormalUsername(group) {
  const firstPool = FIRST_NAMES[group] || [];
  const lastPool  = LAST_NAMES[group]  || [];

  if (!firstPool.length) {
    return { username: "unknown", group };
  }

  const first = firstPool[Math.floor(rand() * firstPool.length)];
  const includeLast = rand() < 0.70 && lastPool.length > 0;

  let username = first;
  let pattern = "first_only"; // label zodat we later suffix rules kunnen toepassen

  if (includeLast) {
    const last = lastPool[Math.floor(rand() * lastPool.length)];
    const separators = [".", "_", "-"];
    const sep = separators[Math.floor(rand() * separators.length)];

    const patternRoll = rand();

    if (patternRoll < 0.45) {
      username = first + sep + last;
      pattern = (sep === ".") ? "first_sep_last_dot"
              : (sep === "-") ? "first_sep_last_dash"
              : "first_sep_last_underscore";
    } else if (patternRoll < 0.65) {
      username = last + sep + first;
      pattern = (sep === ".") ? "last_sep_first_dot"
              : (sep === "-") ? "last_sep_first_dash"
              : "last_sep_first_underscore";
    } else if (patternRoll < 0.85) {
      username = first + last;     // geen separator
      pattern = "firstlast";
    } else {
      username = last + first;     // geen separator
      pattern = "lastfirst";
    }
  } else {
    // first only
    const variantRoll = rand();

    if (variantRoll < 0.35) {
      const year = 1950 + Math.floor(rand() * 71);
      username += year;
      pattern = "first_year";
      return { username: username.toLowerCase(), group };
    } else if (variantRoll < 0.65) {
      username += Math.floor(rand() * 9999);
      pattern = "first_digits";
      return { username: username.toLowerCase(), group };
    } else if (variantRoll < 0.80) {
      const year = 1950 + Math.floor(rand() * 71);
      const sep = rand() < 0.5 ? "_" : "-";
      username += sep + year;
      pattern = "first_sep_year";
      return { username: username.toLowerCase(), group };
    }

  }

  // ===== SUFFIX RULES =====
  // Verboden suffix bij separator formats met . of - 
  const forbidSuffix =
    pattern === "first_sep_last_dot" ||
    pattern === "last_sep_first_dot" ||
    pattern === "first_sep_last_dash" ||
    pattern === "last_sep_first_dash";

  // Optioneel: ook underscore clean houden 
  // || pattern === "first_sep_last_underscore" ||
  // || pattern === "last_sep_first_underscore";

  if (!forbidSuffix) {
    // “Vaak” suffix bij single-name en concatenated formats
    // - bij first_only: heel vaak suffix
    // - bij firstlast/lastfirst: best vaak suffix
    const suffixChance =
      (pattern === "first_only") ? 0.78 :
      (pattern === "firstlast" || pattern === "lastfirst") ? 0.55 :
      0.30;

    if (rand() < suffixChance) {
      // mix jaar vs digits
      if (rand() < 0.55) {
        const year = 1968 + Math.floor(rand() * 58); // 1968–2025-ish
        username += year;
      } else {
        const digits = (rand() < 0.55)
          ? Math.floor(rand() * 99)     // 0-98
          : Math.floor(rand() * 9999);  // 0-9998
        username += digits;
      }
    }
  }

  return { username: username.toLowerCase(), group };
}

/* ===== RANDOM USER ===== */

function getRandomUserByGroup(group) {
  const weirdChance = 0.35; // was 0.15

  if (rand() < weirdChance) {
    const weird = generateWeirdUsername(group);
    if (weird) return weird;
  }
  return generateNormalUsername(group);
}

function getTrafficType(){
  return rand() < 0.75 ? "local" : "external";
}

function pickFromWeights(weightObj) {

  const entries = Object.entries(weightObj);
  const total = entries.reduce((sum, [, weight]) => sum + weight, 0);

  let r = rand() * total;

  for (const [key, weight] of entries) {
    if (r < weight) return key;
    r -= weight;
  }

  // fallback
  return entries[0][0];
}

function getWeightedGroup() {

  if (!REGION_MAP[ACTIVE_REGION]) {
    return pickFromWeights(GROUP_WEIGHTS);
  }

  const allowed = REGION_MAP[ACTIVE_REGION];
  const filtered = {};

  for (const key of allowed) {
    if (GROUP_WEIGHTS[key]) {
      filtered[key] = GROUP_WEIGHTS[key];
    }
  }

  return pickFromWeights(filtered);
}

function getRandomUser() {
  const group = getWeightedGroup();

  if (SESSION.usernameStyle === "weird-heavy") {
    if (rand() < 0.75) return generateWeirdUsername(group) || generateNormalUsername(group); // was 0.6
  }

  if (SESSION.usernameStyle === "mixed") {
    if (rand() < 0.45) return generateWeirdUsername(group) || generateNormalUsername(group); // was 0.3
  }

  return getRandomUserByGroup(group);
}

function applyUILanguage(group){

  const ui = UI_TEXT[group] || UI_TEXT["us"];

  const backBtn = document.getElementById("backBtn");
  if (backBtn) backBtn.textContent = ui.back;
}

function deriveToken(session) {
  if (!session) return "";

  // simpele pseudo-hash (visueel logisch, geen echte crypto)
  let hash = 0;
  for (let i = 0; i < session.length; i++) {
    hash = (hash << 5) - hash + session.charCodeAt(i);
    hash |= 0;
  }

  return Math.abs(hash).toString(16).toUpperCase();
}

function pickUsernameGroup(networkGroup) {

  const foreignChance = 0.10;

  if (rand() > foreignChance) {
    return networkGroup;
  }

  const groups = Object.keys(GROUP_WEIGHTS)
    .filter(g => g !== networkGroup);

  if (!groups.length) return networkGroup;

  return groups[Math.floor(rand() * groups.length)];
}

let NETWORK_GROUP = getWeightedGroup();
let USERNAME_GROUP = pickUsernameGroup(NETWORK_GROUP);

let SITE_USER_OBJ  = getRandomUserByGroup(USERNAME_GROUP);
let SITE_USER = SITE_USER_OBJ.username;

applyUILanguage(NETWORK_GROUP);

function seedAccessLogIfEmpty() {
  if (accessLogBuffer.length) return;

  pushAccessLog(generateOldLog());
  pushAccessLog(generateOldLog());
}

seedAccessLogIfEmpty();

// Intro minimal: direct zichtbaar maken
const intro = document.getElementById("introScreen");
intro.classList.add("ready");

let SESSION = generateSessionProfile();
generatePolicyDecision();

const selectedTheme = getThemeForGroup(NETWORK_GROUP);
applyTheme(selectedTheme);

/* ================= TITLE / HASH STATE ================= */

let typedLength = 0;
let typingSpeed = 16;
let lastTypeTime = 0;
let titlePause = 1500;
let titleFinished = 0;

let RANDOM_ASCII =
  ASCII_FIGURES[Math.floor(rand() * ASCII_FIGURES.length)];

function getHashText() {

const lines = [
  `Session-ID: ${rollingSession}`,
  `User-ID: ${SITE_USER}`,
  `X-Auth-Token: ${CAPTURED_PASSWORD || ""}`,
  `Geo: ${GROUP_LABELS[NETWORK_GROUP] || NETWORK_GROUP}`,
];

lines.push(
  "",
  "Authorization-Engine: RBAC v2.3",
  `Policy-Check: ${POLICY_DECISION.status} (${POLICY_DECISION.reason})`,
  "",
  "HTTP 403 — ACCESS DENIED",
  "",
  RANDOM_ASCII
);

  return lines.join("\n");
}

let hashTypedLength = 0;
let hashLastTypeTime = 0;
let hashFinished = 0;
let hashPause = 2500;

/* ================= PHASE TIMING ================= */

const blackoutDuration = 250;
const introDuration = 700;
let phaseStart = 0;

function setState(newState, timestamp) {

  phase = newState;
  phaseStart = timestamp || performance.now();

  switch (newState) {

    case STATES.CURTAIN:
      curtainOffset = -window.innerHeight;
      curtainPauseStart = 0;
      break;

    case STATES.HASH:
      hashTypedLength = 0;
      hashLastTypeTime = 0;
      hashFinished = 0;
      break;

    case STATES.BLACKOUT:
      blackoutStart = timestamp;
      break;

    case STATES.MATRIX_INTRO:
      terminalElement.classList.add("open");
      startTerminalSequence();
      break;
  }
}

/* ================= RESIZE ================= */

let introDrops = [];
let introColumns = 0;

function resize() {

  const ratio = window.devicePixelRatio || 1;
  const cssWidth  = window.innerWidth;
  const cssHeight = window.innerHeight;

  canvas.width  = cssWidth  * ratio;
  canvas.height = cssHeight * ratio;

  canvas.style.width  = cssWidth  + "px";
  canvas.style.height = cssHeight + "px";

  ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  ctx.imageSmoothingEnabled = false;

  /* ================= MATRIX BASIS ================= */

  curtainColumns = Math.floor(cssWidth / curtainColumnSpacing);
  matrixColumns  = Math.floor(cssWidth / matrixFontSize);

  /* ================= INTRO MATRIX (FASE -100) ================= */

const INTRO_DEPTH_LAYERS = 3;

introColumns = Math.max(
  8,
  Math.floor(cssWidth / matrixFontSize)
);

// array van lagen
introDrops = [];

for (let d = 0; d < INTRO_DEPTH_LAYERS; d++) {

  const layerDrops = [];

  for (let i = 0; i < introColumns; i++) {
    layerDrops[i] = rand() * -50;
  }

  introDrops.push(layerDrops);
}

  /* ================= MATRIX ARRAYS RESET ================= */

  drops = [];
  stacks = [];
  speeds = [];
  maxLengths = [];
  spawnRates = [];
  drift = [];
  driftOffset = [];

  for (let i = 0; i < matrixColumns; i++) {

    drops[i]  = rand() * -100;
    stacks[i] = [];

    speeds[i] = 0.08 + rand() * 0.25;
    maxLengths[i] = 10 + Math.floor(rand() * 40);
    spawnRates[i] = 0.3 + rand() * 0.6;

    drift[i] = (rand() - 0.5) * 6;
    driftOffset[i] = 0;
  }

  /* ================= CURTAIN GRID ================= */

  const rows = Math.ceil(cssHeight / curtainLineHeight);
  curtainGrid = [];

  for (let c = 0; c < curtainColumns; c++) {

    curtainGrid[c] = [];

    for (let r = 0; r < rows * curtainDepth; r++) {

      curtainGrid[c][r] =
        curtainChars[Math.floor(rand() * curtainChars.length)];
    }
  }

  curtainOffset = -cssHeight;
}

/* ===== RESIZE / START ===== */

window.addEventListener("resize", resize);
resize();

/* ================= RENDER ================= */

ctx.shadowBlur = 0;
ctx.shadowColor = "transparent";
ctx.textAlign = "left";

function charAt(col, row, blockIndex) {
  let x =
    (col * 374761393) ^
    (row * 668265263) ^
    (blockIndex * 1442695041) ^
    WORLD_SEED;

  x = (x ^ (x >>> 13)) * 1274126177;
  x = x ^ (x >>> 16);

  const idx = (x >>> 0) % curtainChars.length;
  return curtainChars[idx];
}



const TITLE_LINE_HEIGHT = 18;


function captureCurtainPassword() {

  const H = window.innerHeight;
  const rowsOnScreen = Math.ceil(H / curtainLineHeight);

  const blockWidth = CURTAIN_BLOCK_WIDTH;
  const gapWidth   = CURTAIN_GAP_WIDTH;

  const rowOffset = curtainOffset / curtainLineHeight;
  const baseRow   = Math.floor(rowOffset);

  // kies willekeurige zichtbare kolom
  const visibleColumns = [];

  for (let c = 0; c < curtainColumns; c++) {
    const inBlock = (c % (blockWidth + gapWidth)) < blockWidth;
    if (inBlock) visibleColumns.push(c);
  }

  if (!visibleColumns.length) return;

  const chosenCol = visibleColumns[Math.floor(rand() * visibleColumns.length)];
  const blockIndex = Math.floor(chosenCol / (blockWidth + gapWidth));

  const midRow = Math.floor(rowsOnScreen / 2);
  const worldRow = baseRow + midRow;

  let password = "";
  for (let i = 0; i < 8; i++) {
    const col = (chosenCol + i) % curtainColumns;
    password += charAt(col, worldRow, blockIndex);
  }

  CAPTURED_PASSWORD = password;
}

function wrapLine(ctx, line, maxWidth) {
  // BELANGRIJK: lege regel blijft een “regel”
  if (line === "") return [""];

  const words = line.split(" ");
  let current = "";
  const wrapped = [];

  for (let w of words) {
    const test = current ? current + " " + w : w;
    if (ctx.measureText(test).width > maxWidth) {
      wrapped.push(current);
      current = w;
    } else {
      current = test;
    }
  }

  // ook als current leeg is (kan gebeuren bij rare input), push dan toch 1 regel
  if (current !== "") wrapped.push(current);
  if (!wrapped.length) return [""];

  return wrapped;
}

function elapsedInState(timestamp) {
  return timestamp - phaseStart;
}

function render(timestamp){

  const runtime = experienceStart ? (timestamp - experienceStart) : 0;

if (experienceStart && runtime > LOOP_DURATION) {
  resetExperience();
  experienceStart = performance.now();
}

  if (!lastTime) lastTime = timestamp;

  let delta = (timestamp - lastTime) / 1000;

  if (forceSpike > 0) {
    delta += forceSpike;
    forceSpike = 0;
  }

  lastTime = timestamp;

  /* ===== BACKGROUND ===== */

const isMatrixTrailPhase = phase === 200 || phase === 300;

if (isMatrixTrailPhase) {
  ctx.fillStyle = "rgba(0,0,0,0.12)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
} else {
  ctx.clearRect(0,0,canvas.width,canvas.height);
}

  ctx.textBaseline = "top";

/* ===== FASE -100 INTRO ===== */

if (phase === STATES.INTRO) {

  const height = window.innerHeight;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";

  const depthConfig = [
    { speed: 0.006, alpha: 0.15, scale: 0.9 },
    { speed: 0.010, alpha: 0.30, scale: 1.0 },
    { speed: 0.018, alpha: 0.55, scale: 1.1 }
  ];

  for (let d = 0; d < introDrops.length; d++) {

    const layer = introDrops[d];
    const cfg   = depthConfig[d];

    ctx.globalAlpha = cfg.alpha;
    ctx.font = (matrixFontSize * cfg.scale) + 
               "px 'Noto Sans Mono','IBM Plex Mono',monospace";

    for (let i = 0; i < introColumns; i++) {

      const x = i * matrixFontSize;
      const y = layer[i] * matrixFontSize;

      const char =
        matrixChars[Math.floor(rand() * matrixChars.length)];

      const baseColor =
  currentPalette[i % currentPalette.length];

const isBlack =
  baseColor.toLowerCase() === "#000000";

if (isBlack) {

  // 1) lift zonder dubbele alpha-vermenigvuldiging
  ctx.save();
  ctx.globalAlpha = 1; 
  ctx.fillStyle = "rgba(200,200,200,0.25)";
  ctx.fillText(char, x, y);
  ctx.restore();

  // 2) echte zwarte laag met diepte-alpha
  ctx.globalAlpha = cfg.alpha;
  ctx.fillStyle = baseColor;
  ctx.fillText(char, x, y);

} else {

  ctx.fillStyle = baseColor;
  ctx.fillText(char, x, y);
}

      layer[i] += cfg.speed;

      if (y > height) {
        layer[i] = rand() * -20;
      }
    }
  }

  ctx.globalAlpha = 1;
  requestAnimationFrame(render);
  return;
}

/* ===== FASE -50 TITLE ===== */

if (phase === STATES.TITLE) {

  const currentTitle = getTitleText();

  if (!lastTypeTime) lastTypeTime = timestamp;

  if (typedLength < currentTitle.length) {
    if (timestamp - lastTypeTime > typingSpeed) {
      typedLength++;
      lastTypeTime = timestamp;
    }
  } else {
    if (!titleFinished) titleFinished = timestamp;
    if (timestamp - titleFinished > titlePause) {
      phase = 0;
      curtainOffset = -window.innerHeight;
      curtainPauseStart = 0;
    }
  }

  ctx.fillStyle = "#ffffff";
  ctx.font = "16px monospace";

  const text = currentTitle.substring(0, typedLength);
  const lines = text.split("\n");

  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], 22, 18 + (i * 18));
  }

  if (Math.floor(timestamp / 500) % 2 === 0) {
    const lines = text.split("\n");
const lastLine = lines[lines.length - 1] || "";

const cursorX = 22 + ctx.measureText(lastLine).width;
const cursorY = 18 + ((lines.length - 1) * 18);

ctx.fillRect(cursorX + 4, cursorY, 8, 16);

  }

  requestAnimationFrame(render);
  return;
}

  /* ===== FASE 0 GORDIJN ===== */

  if (phase === STATES.CURTAIN) {

    ctx.font = curtainFontSize + "px 'IBM Plex Mono', monospace";
ctx.shadowBlur = 0;
ctx.shadowColor = "transparent";

    const H = window.innerHeight;
    const rowsOnScreen = Math.ceil(H / curtainLineHeight);

    const blockWidth = CURTAIN_BLOCK_WIDTH;
    const gapWidth   = CURTAIN_GAP_WIDTH;

    const rowOffset = curtainOffset / curtainLineHeight;
    const baseRow   = Math.floor(rowOffset);
    const frac      = rowOffset - baseRow;

    const extra = 4;

    for (let c = 0; c < curtainColumns; c++) {

      const blockIndex = Math.floor(c / (blockWidth + gapWidth));
      const inBlock    = (c % (blockWidth + gapWidth)) < blockWidth;
      if (!inBlock) continue;

const x = c * curtainColumnSpacing;
const baseColor = currentPalette[blockIndex % currentPalette.length];
const isBlack = baseColor.toLowerCase() === "#000000";

for (let r = -extra; r < rowsOnScreen + extra; r++) {
  if ((r & 3) !== 0) continue;

  const worldRow = baseRow + r;
  const y = (r + frac) * curtainLineHeight;

  if (y < -curtainFontSize || y > H + curtainFontSize) continue;

  const ch = charAt(c, worldRow, blockIndex);

  // 1) compensatie-laag voor zwart (zodat het zichtbaar blijft)
  if (isBlack) {
    ctx.save();
    ctx.fillStyle = "rgba(200,200,200,0.6)";
    ctx.fillText(ch, Math.floor(x), Math.floor(y));
    ctx.restore();
  }

  // 2) normale laag
  ctx.fillStyle = baseColor;
  ctx.fillText(ch, Math.floor(x), Math.floor(y));
}

    }

    const firstStop = 0;
    const finalStop = H * curtainDepth;

    if (curtainOffset < firstStop) {
      curtainSpeed = Math.min(curtainSpeed + acceleration * delta, 1400);
      curtainOffset += curtainSpeed * delta;
    } else if (!curtainPauseStart) {
  curtainOffset = firstStop;
  curtainPauseStart = timestamp;

  if (!CAPTURED_PASSWORD) {
    captureCurtainPassword();
  }
} else if (timestamp - curtainPauseStart < curtainPauseDuration) {
      // pause
    } else if (curtainOffset < finalStop) {
      curtainSpeed += acceleration * delta;
      curtainOffset += curtainSpeed * delta;
    } else {
      setState(STATES.HASH, timestamp);
      hashTypedLength = 0;
      hashLastTypeTime = 0;
      hashFinished = 0;
      curtainPauseStart = 0;
      curtainSpeed = 50;
rollingDone = false;
rollingTriggered = false;
finalSessionId = Array.from(crypto.getRandomValues(new Uint8Array(12)))
  .map(b => b.toString(16).padStart(2,"0"))
  .join("")
  .slice(0,16);
rollingSession = "";
    }

    requestAnimationFrame(render);
    return;
  }

  /* ===== FASE 50 HASH SCREEN ===== */

if (phase === STATES.HASH) {

  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!hashLastTypeTime) hashLastTypeTime = timestamp;

  /* ===== ROLLING ===== */

  const now = performance.now();
  const rollingDuration = 900;
  const settleDuration = 400;

  if (rollingTriggered && !rollingDone) {

    const elapsed = now - rollingStartTime;

    if (elapsed < rollingDuration) {

      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
      rollingSession = "";

      for (let i = 0; i < 16; i++) {
        rollingSession += chars[Math.floor(rand() * chars.length)];
      }

    } else {
      rollingSession = finalSessionId;
      rollingDone = true;
    }
  }

const fullHash = getHashText();
const sessionLineIndex = fullHash.indexOf("Session-ID:");

if (!rollingTriggered && hashTypedLength >= sessionLineIndex - 5) {
  rollingTriggered = true;
  rollingStartTime = performance.now();
}

  /* ===== TYPING ===== */

  if (hashTypedLength < fullHash.length) {
    if (timestamp - hashLastTypeTime > typingSpeed) {
      hashTypedLength++;
      hashLastTypeTime = timestamp;
    }
  } else {
    if (!hashFinished) hashFinished = timestamp;

    if (timestamp - hashFinished > hashPause) {
  setState(STATES.BLACKOUT, timestamp);
}
  }

  /* ===== VISIBILITY LOGIC ===== */

  const rawLines = fullHash.split(/\r?\n/);
  let charCounter = 0;
  const visibleLines = [];

  for (const line of rawLines) {

    const lineLength = line.length + 1;

    if (charCounter + lineLength <= hashTypedLength) {
      visibleLines.push(line);
    }
    else if (charCounter < hashTypedLength) {

      if (line.startsWith("Session-ID:")) {
        visibleLines.push(`Session-ID: ${rollingSession}`);
      } else {
        visibleLines.push(line.substring(0, hashTypedLength - charCounter));
      }

      break;
    }
    else {
      break;
    }

    charCounter += lineLength;
  }

  /* ===== RENDER TEXT ===== */

  ctx.fillStyle = "#ffffff";
  ctx.font = "16px monospace";

  const maxWidth = window.innerWidth - 44;
  const lineHeight = 18;
  let y = 18 + (lineHeight * 2);

  for (const line of visibleLines) {

    const wrapped = wrapLine(ctx, line, maxWidth);

    for (const wl of wrapped) {
      if (wl !== "") ctx.fillText(wl, 22, y);
      y += lineHeight;
    }
  }

  requestAnimationFrame(render);
  return;
}

/* ===== FASE 100 BLACKOUT ===== */

if (phase === STATES.BLACKOUT) {

  const elapsed = timestamp - blackoutStart;
  const progress = Math.min(elapsed / blackoutDuration, 1);

  // 1) snelle fade naar zwart
  ctx.fillStyle = `rgba(0,0,0,${progress})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // 2) korte witte security flash in begin
  if (elapsed < 60) {
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  // 3) horizontale scan band
  if (elapsed < 140) {
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(180,40,40,1)";
    const bandY = (elapsed / 140) * canvas.height;
    ctx.fillRect(0, bandY, canvas.width, 8);
    ctx.restore();
  }

  // volledig zwart -> door naar matrix intro
  if (elapsed >= blackoutDuration && !terminalStarted) {
    terminalStarted = true;
    setState(STATES.MATRIX_INTRO, timestamp);
  }

  requestAnimationFrame(render);
  return;
}

  /* ===== FASE 200 + 300 MATRIX ===== */

  ctx.font = matrixFontSize + "px 'Noto Sans Mono', 'IBM Plex Mono', monospace";

  for (let i = 0; i < matrixColumns; i++) {

    const x = (i * matrixFontSize) + driftOffset[i];
    const y = drops[i] * matrixFontSize;
    const colColor = currentPalette[i % currentPalette.length];

    if (phase === STATES.MATRIX_INTRO && timestamp - phaseStart > introDuration) {
      phase = 300;

      terminalPhaseStarted = true;
      terminalGlitchActive = true;
      terminalGlitchBursts = 2; // eerste twee geforceerd
      terminalGlitchEnd = timestamp + 50;
    }


if (phase === STATES.MATRIX_INTRO) {

  const depthLayers = [
    { speed: 0.55, alpha: 0.18, scale: 0.85 },
    { speed: 1.0,  alpha: 0.40, scale: 1.0  },
    { speed: 1.9,  alpha: 0.85, scale: 1.12 }
  ];

  const headY = drops[i] * matrixFontSize;

  for (let d = 0; d < depthLayers.length; d++) {

    const layer = depthLayers[d];

    const layerY = headY * layer.speed;

    ctx.font =
      (matrixFontSize * layer.scale) +
      "px 'Noto Sans Mono','IBM Plex Mono',monospace";

    const char =
      matrixChars[Math.floor(rand()*matrixChars.length)];

    if (d === depthLayers.length - 1) {
      // voorste laag = head highlight
      ctx.fillStyle = "#e6e6e6";
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 12;
      ctx.shadowColor = "rgba(230,230,230,0.9)";
    } else {
      const isBlack = colColor.toLowerCase() === "#000000";

if (isBlack) {
  ctx.fillStyle = "#d0d0d0";   // lifted zwart
  ctx.globalAlpha = layer.alpha * 0.7;
} else {
  ctx.fillStyle = colColor;
  ctx.globalAlpha = layer.alpha;
}
      ctx.shadowBlur = 0;
    }

    ctx.fillText(char, x, layerY);
  }

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  drops[i] += 12 * delta;

  if (drops[i] * matrixFontSize > canvas.height) {
    drops[i] = rand() * -40;
  }

  ctx.globalAlpha = 1;

  drops[i] += 12 * delta;

  if (drops[i] * matrixFontSize > canvas.height) {
    drops[i] = rand() * -40;
  }
} else {

      if (rand() < spawnRates[i]) {
        stacks[i].unshift(matrixChars[Math.floor(rand()*matrixChars.length)]);
      }

      if (stacks[i].length > maxLengths[i]) stacks[i].pop();

      for (let t = 0; t < stacks[i].length; t++) {

        const trailY = y - (t * trailSpacing);
        if (trailY < 0) continue;

        const alpha = 1 - (t / stacks[i].length);

if (t === 0) {

  // head glow
  ctx.fillStyle = "#e6e6e6";
  ctx.globalAlpha = 0.25;

  ctx.shadowBlur = 12;
  ctx.shadowColor = "rgba(230,230,230,0.9)";

} else {

  const baseColor = currentPalette[i % currentPalette.length];
const isBlack = baseColor.toLowerCase() === "#000000";

if (isBlack) {

  // 1) subtiele lift-laag
  ctx.save();
  ctx.fillStyle = "rgba(200,200,200," + (alpha * 0.35) + ")";
  ctx.fillText(stacks[i][t], x, trailY);
  ctx.restore();

  // 2) echte zwarte laag erboven
  ctx.fillStyle = baseColor;
  ctx.globalAlpha = alpha * 0.9;

} else {

  ctx.fillStyle = baseColor;
  ctx.globalAlpha = alpha * 0.8;
}

  ctx.shadowBlur = 0;
}



        ctx.fillText(stacks[i][t], x, trailY);
ctx.shadowBlur = 0;
ctx.globalAlpha = 1;

      }

      drops[i] += speeds[i] * 15 * delta;

      if (drops[i] * matrixFontSize > canvas.height + 120) {
        drops[i] = rand() * -20;
        stacks[i] = [];
      }
    }
  }

/* ===== GLITCH TRIGGER (PHASE 200 ONLY) ===== */

if (phase === STATES.MATRIX_INTRO) {

  if (!glitchActive && timestamp >= nextGlitchTime) {

    glitchActive = true;

    // 40% kans op dubbele burst
    glitchBursts = rand() < 0.4 ? 2 : 1;

    glitchEnd = timestamp + 45;

    // volgende glitch pas over 900–2200ms
    nextGlitchTime = timestamp + 900 + rand() * 1300;
  }
}

/* ===== GLITCH FLASH ===== */

if (glitchActive) {

  if (timestamp >= glitchEnd) {

    glitchBursts--;

    if (glitchBursts > 0) {
      // korte onderbreking tussen flitsen
      glitchEnd = timestamp + 70; 
      glitchActive = "gap";       // tijdelijk uit
    } else {
      glitchActive = false;
    }
  }

  if (glitchActive === true) {

    ctx.save();

    ctx.globalAlpha = 0.12 + rand() * 0.06;
    ctx.globalCompositeOperation = "source-over";

    ctx.fillStyle = rand() < 0.5
      ? "rgba(160,30,25,1)"
      : "rgba(190,60,20,1)";

    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.globalAlpha = 0.18;
    const bandY = rand() * canvas.height;
    const bandHeight = 4 + rand() * 10;
    ctx.fillRect(0, bandY, canvas.width, bandHeight);

    ctx.restore();
  }

  // gap-afhandeling
  if (glitchActive === "gap" && timestamp >= glitchEnd) {
    glitchActive = true;
    glitchEnd = timestamp + 45;
  }
}


/* ===== TERMINAL GLITCH ENGINE ===== */

if (phase === STATES.MATRIX_RUN) {

  // normale random scheduling
  if (!terminalGlitchActive && timestamp >= terminalNextGlitch) {

    terminalGlitchActive = true;

    // 25% kans op dubbele burst
    terminalGlitchBursts = rand() < 0.25 ? 2 : 1;

    terminalGlitchEnd = timestamp + 40;

    // volgende volledig random interval (5–30 sec)
    terminalNextGlitch =
      timestamp + (5000 + rand() * 25000);
  }
}

if (terminalGlitchActive) {

  // teken glitch
  ctx.save();

  ctx.globalAlpha = 0.08 + rand() * 0.08;
  ctx.fillStyle = "rgba(170,40,30,1)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.globalAlpha = 0.15;
  const bandY = rand() * canvas.height;
  ctx.fillRect(0, bandY, canvas.width, 6 + rand() * 10);

  ctx.restore();

  // einde burst?
  if (timestamp >= terminalGlitchEnd) {

    terminalGlitchBursts--;

    if (terminalGlitchBursts > 0) {

      // korte tussenruimte bij dubbele burst
      terminalGlitchEnd = timestamp + 60;

    } else {

      terminalGlitchActive = false;
    }
  }
}

  requestAnimationFrame(render);
}

  
/* ================= TERMINAL ================= */

// genereer 2 eerdere logregels
function generateOldLog() {
  const fakeGroup = getWeightedGroup();

  const fakeIP =
    `${Math.floor(rand()*255)}.` +
    `${Math.floor(rand()*255)}.` +
    `${Math.floor(rand()*255)}.` +
    `${Math.floor(rand()*255)}`;

  const fakeUserObj = getRandomUserByGroup(fakeGroup);
  const fakeUser = fakeUserObj.username;

  const fakeSize = Math.floor(120 + rand()*200);

  const protocol = rand() < 0.7 ? "HTTP/1.1" : "HTTP/2";

  const status = 403;

  const countryLabel = GROUP_LABELS[fakeGroup] || fakeGroup;

  const text =
    `${fakeIP} - ${fakeUser} - [${getNginxTimestamp()}] "GET / ${protocol}" ${status} ${fakeSize} "-" "-" "Mozilla/5.0" "${countryLabel}"`;

  const theme = getThemeForGroup(fakeGroup);

  // 403 => error-kleur
  let logColor = theme.error;

  // voorkom zwart-op-zwart in terminal
  if (logColor.toLowerCase() === "#000000") {
    logColor = theme.secondary;
  }

  return {
    text,
    color: logColor
  };
}

function getNginxTimestamp() {
  const now = new Date();
  const pad = n => n.toString().padStart(2, "0");
  return `${now.getFullYear()}/${pad(now.getMonth()+1)}/${pad(now.getDate())} ` +
         `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
}

function generateCurlLines() {

  const protocol =
  SESSION.protocolBias === "http2"
    ? (rand() < 0.7 ? "HTTP/2" : "HTTP/1.1")
    : (rand() < 0.8 ? "HTTP/1.1" : "HTTP/2");

  LAST_PROTOCOL = protocol;

    const base = SESSION.latencyBase;
    const latency = (base + rand() * 20).toFixed(0);


  return [
    `* Connected to ${DOMAIN || "unknown"}`,
    `> GET / ${protocol || "HTTP/1.1"}`,
    `> Host: ${DOMAIN || "unknown"}`,
    `< ${protocol || "HTTP/1.1"} 403`,
    `HTTP 403 — Access Forbidden (${latency}ms)`
  ];
}


async function resolveVisitorIP() {
  try {

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 1500);

    const res = await fetch("ip.php", {
      cache: "no-store",
      signal: controller.signal
    });

    clearTimeout(timeout);

    if (!res.ok) throw new Error("bad response");

    const data = await res.json();
    VISITOR_IP = data.ip || "0.0.0.0";

  } catch (e) {
    VISITOR_IP = "0.0.0.0";
  }

  HOST_LABEL = VISITOR_IP;
}

function getUserAgent() {
  return navigator.userAgent;
}

function runTerminal(){

  if (terminalRunning) {
    console.warn("Terminal already running");
    return;
  }

  terminalRunning = true;

  const terminalOutput = document.getElementById("terminalOutput");
    const terminalBody   = document.getElementById("terminalBody");

    terminalOutput.innerHTML = "";

  /* ===== LOCAL TIMESTAMP (NL + DST correct) ===== */
  function getLocalTimestamp() {
    const now = new Date();

    return new Intl.DateTimeFormat("sv-SE", {
      timeZone: "Europe/Amsterdam",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    }).format(now).replace(",", "");
  }

  function createPromptLine(){
    const line = document.createElement("div");
    line.innerHTML =
      '<span class="userhost">' + SITE_USER + '@' + HOST_LABEL + '</span>'+
      '<span class="colon">:</span>'+
      '<span class="path">~</span>'+
      '<span class="symbol">$ </span>';
    terminalOutput.appendChild(line);
    return line;
  }

function createRootPromptLine(){
  const line = document.createElement("div");
  line.innerHTML =
    '<span class="userhost">root@' + DOMAIN + '</span>'+
    '<span class="colon">:</span>'+
    '<span class="path">/var/log</span>'+
    '<span class="symbol"># </span>';
  terminalOutput.appendChild(line);
  return line;
}

  function typeOnLine(line,text,callback){

    const cursor = document.createElement("span");
    cursor.className = "cursor";
    line.appendChild(cursor);

    let i = 0;

    function next(){
      if(i < text.length){
        line.insertBefore(
          document.createTextNode(text[i]),
          cursor
        );
        i++;
        terminalBody.scrollTop = terminalBody.scrollHeight;
        setTimeout(next, 18 + rand()*25);
      } else {
        cursor.remove();
        if(callback) setTimeout(callback,300);
      }
    }

    next();
  }

  function outputLinesRandom(lines, minDelay, maxDelay, callback){

    let i = 0;

    function next(){
      if(i >= lines.length){
        if(callback) callback();
        return;
      }

      const div = document.createElement("div");
      div.className = lines[i].includes("403")
        ? "error"
        : "output";

      div.textContent = lines[i];
      terminalOutput.appendChild(div);
      terminalBody.scrollTop = terminalBody.scrollHeight;

      i++;

      const delay = minDelay + rand() * (maxDelay - minDelay);
      setTimeout(next, delay);
    }

    next();
  }

/* ===== SEQUENCE ===== */

function sleep(ms){
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function typeLine(line, text, speed = 22){
  const cursor = document.createElement("span");
  cursor.className = "cursor";
  line.appendChild(cursor);

  for(let i = 0; i < text.length; i++){
    line.insertBefore(document.createTextNode(text[i]), cursor);
    await sleep(speed);
    terminalBody.scrollTop = terminalBody.scrollHeight;
  }

  cursor.remove();
  await sleep(200);
}

async function printLines(lines, minDelay = 80, maxDelay = 140){
  for (const l of lines) {
    const row = document.createElement("pre");
    row.className = "term-line " + (l.includes("403") ? "error" : "output");
    row.textContent = l;
    terminalOutput.appendChild(row);
    terminalBody.scrollTop = terminalBody.scrollHeight;

    const delay = minDelay + rand() * (maxDelay - minDelay);
    await sleep(delay);
  }
}

async function runSequence(){

  // 1) USER CONTEXT
  const firstPrompt = createPromptLine();
  await sleep(200);
  await typeLine(firstPrompt, `ping ${DOMAIN}`);

  const pingCount = 2 + Math.floor(rand() * 9); 
  const pingLines = [`PING ${DOMAIN} (${IP_ADDRESS}) 56 data bytes`];
  const times = [];

  for (let i = 1; i <= pingCount; i++) {
    const base = SESSION.latencyBase;
    const jitter = (rand() * 4 - 2);
    const time = parseFloat((base + jitter).toFixed(1));
    times.push(time);
    pingLines.push(`64 bytes from ${IP_ADDRESS}: icmp_seq=${i} ttl=53 time=${time} ms`);
  }

  const min = Math.min(...times).toFixed(1);
  const max = Math.max(...times).toFixed(1);
  const avg = (times.reduce((a,b)=>a+b,0) / times.length).toFixed(1);
  const variance = times.reduce((a,b)=>a + Math.pow(b - avg, 2), 0) / times.length;
  const mdev = Math.sqrt(variance).toFixed(2);

  pingLines.push("^C");
  pingLines.push(`--- ${DOMAIN} ping statistics ---`);
  pingLines.push(`${pingCount} packets transmitted, ${pingCount} received, 0% packet loss`);
  pingLines.push(`rtt min/avg/max/mdev = ${min}/${avg}/${max}/${mdev} ms`);

  await printLines(pingLines);

  // 2) CURL
  const secondPrompt = createPromptLine();
  await typeLine(secondPrompt, `curl -v ${DOMAIN}`);

  const curlLines = generateCurlLines();
  await printLines(curlLines);

// ===== SERVER CONTEXT =====

const rootPrompt = createRootPromptLine();
await sleep(200);

// laat het commando echt typen
await typeLine(rootPrompt, "tail -n 3 access.log");

// Zorg dat er al "history" is zodat tail -n 3 altijd iets heeft
seedAccessLogIfEmpty();

const responseSize = Math.floor(120 + rand() * 80);

const tokenPart = CAPTURED_PASSWORD
  ? ` "X-Auth-Token: ${CAPTURED_PASSWORD}"`
  : "";

const sessionPart = finalSessionId
  ? ` "X-Session-ID: ${finalSessionId}"`
  : "";

const logLine =
  `${VISITOR_IP} - ${SITE_USER} - [${getNginxTimestamp()}] "GET / ${LAST_PROTOCOL}" 403 ${responseSize} "-"${tokenPart}${sessionPart} "${getUserAgent()}" "${GROUP_LABELS[NETWORK_GROUP] || NETWORK_GROUP}"`;

// voeg toe aan buffer (persist tussen runs)
pushAccessLog({
  text: logLine,
  color: getComputedStyle(document.documentElement)
    .getPropertyValue("--color-error")
    .trim()
});

// toon echte tail (laatste 3 regels uit buffer)
const tailLines = getTailLines();
await printAccessTail(tailLines);

// nieuwe prompt
const finalPrompt = createRootPromptLine();
const cursor = document.createElement("span");
cursor.className = "cursor";
finalPrompt.appendChild(cursor);
}

async function printAccessTail(lines) {

  for (let i = 0; i < lines.length; i++) {

    const row = document.createElement("pre");
    row.className = "term-line";

    const entry = lines[i];

    if (typeof entry === "string") {
      row.textContent = entry;
      row.style.color = "#ffffff";
    } else {
      row.textContent = entry.text;

      // gebruik altijd entry.color
      row.style.color = entry.color || "#ffffff";
    }

    terminalOutput.appendChild(row);
    terminalBody.scrollTop = terminalBody.scrollHeight;

    const delay = 60 + rand() * 80;
    await sleep(delay);
  }
}

// start
runSequence();

}

async function resetExperience() {
    reseedWorld();
  experienceStart = 0;   

  lastTime = 0;

  typedLength = 0;
  lastTypeTime = 0;
  titleFinished = 0;

  hashTypedLength = 0;
  hashLastTypeTime = 0;
  hashFinished = 0;

  curtainPauseStart = 0;
  blackoutStart = 0;
  phaseStart = 0;

CAPTURED_PASSWORD = null; 
NETWORK_GROUP = getWeightedGroup();

applyUILanguage(NETWORK_GROUP);

SESSION = generateSessionProfile();
generatePolicyDecision();

  glitchActive = false;
  terminalGlitchActive = false;

  terminalStarted = false;
  terminalRunning = false;

  terminalElement.classList.remove("open");
  document.getElementById("terminalOutput").innerHTML = "";
  document.getElementById("terminalTitle").textContent = "";

  USERNAME_GROUP = pickUsernameGroup(NETWORK_GROUP);
SITE_USER_OBJ = getRandomUserByGroup(USERNAME_GROUP);
SITE_USER = SITE_USER_OBJ.username;

  RANDOM_ASCII =
    ASCII_FIGURES[Math.floor(rand() * ASCII_FIGURES.length)];

  const theme = getThemeForGroup(NETWORK_GROUP);
  applyTheme(theme);

  resize();

  const isColdBoot = !hasBootedOnce;
    setState(isColdBoot ? STATES.INTRO : STATES.TITLE);

    document.getElementById("introScreen").style.display =
      hasBootedOnce ? "none" : "flex";

if (!hasBootedOnce) {
  document.body.style.overflow = "auto";
} else {
  document.body.style.overflow = "hidden";
}

  // async dingen pas NA reset
  resolveVisitorIP().then(generateTitleLogs);
}

/* ===== TAB RETURN SPIKE ===== */

document.addEventListener("visibilitychange", () => {

  if (!document.hidden && (phase === 200 || phase === 300)) {
    forceSpike = 0.12 + rand() * 0.15;
  }
});

await resolveVisitorIP();
generateTitleLogs();
animationId = requestAnimationFrame(render);

/* ===== Gedeelde startfunctie ===== */

async function startExperience() {

  document.body.style.overflow = "hidden";

  if (phase !== STATES.INTRO) return;

  hasBootedOnce = true;
  document.getElementById("introScreen").style.display = "none";

  // Nieuwe sessie
  NETWORK_GROUP  = getWeightedGroup();
  USERNAME_GROUP = pickUsernameGroup(NETWORK_GROUP);
  SITE_USER_OBJ  = getRandomUserByGroup(USERNAME_GROUP);
  SITE_USER      = SITE_USER_OBJ.username;

  applyUILanguage(NETWORK_GROUP);

  SESSION = generateSessionProfile();
  generatePolicyDecision();

  /* ===== Dynamische sessieduur ===== */

  if (SESSION.type === "scripted") {
    LOOP_DURATION = 29000 + rand() * 10000;
  }
  else if (SESSION.type === "datacenter") {
    LOOP_DURATION = 30000 + rand() * 15000;
  }
  else {
    LOOP_DURATION = 31000 + rand() * 15000;
  }

  RANDOM_ASCII =
    ASCII_FIGURES[Math.floor(rand() * ASCII_FIGURES.length)];

  const theme = getThemeForGroup(NETWORK_GROUP);
  applyTheme(theme);

  typedLength = 0;
  lastTypeTime = 0;
  titleFinished = 0;

  await resolveVisitorIP();
  generateTitleLogs();

  experienceStart = performance.now();
  setState(STATES.TITLE);
}

/* ===== REGION BUTTONS ===== */

document.querySelectorAll(".region-btn").forEach(btn => {

  btn.addEventListener("click", async () => {

    const region = btn.dataset.region;

    if (region === "more") return;

    ACTIVE_REGION = region;

    await startExperience();
  });

});

/* ===== BACK BUTTON ===== */

const backBtn = document.getElementById("backBtn");

backBtn.addEventListener("click", () => {
  if (history.length > 1) {
    history.back();
  } else {
    window.location.href = "/";
  }
});


/* ===== MORE THEMES OVERLAY ===== */

const overlay = document.getElementById("themesOverlay");
const closeBtn = document.getElementById("closeThemes");
const moreBtn = document.querySelector('[data-region="more"]');

if (overlay && closeBtn && moreBtn) {

  moreBtn.addEventListener("click", () => {
    overlay.classList.add("open");
  });

  closeBtn.addEventListener("click", () => {
    overlay.classList.remove("open");
  });

}

const resetBtn = document.getElementById("resetIntroBtn");

if (resetBtn) {
  resetBtn.addEventListener("click", () => {

    // Stop terminal
    terminalRunning = false;
    terminalStarted = false;

    // Terminal sluiten
    terminalElement.classList.remove("open");
    document.getElementById("terminalOutput").innerHTML = "";
    document.getElementById("terminalTitle").textContent = "";

    // Intro weer tonen
    document.getElementById("introScreen").style.display = "flex";
    document.body.style.overflow = "auto";

    hasBootedOnce = false;

    // Reset state
    setState(STATES.INTRO);
  });
}

})();
</script>

<button id="resetIntroBtn" class="footer-reset">
  ◀ RESET
</button>

<footer class="copyright">
  © 2026 S.V.
</footer>

</body>
</html>

