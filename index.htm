<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<title>403 - ACCESS DENIED</title>

<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./style/style.css?v=1">
</head>

<body>
<canvas id="matrix"></canvas>
<div class="status">403 - ACCESS DENIED</div>
<div id="introScreen" class="intro-screen">

<div class="intro-title">
  403
</div>

<div class="intro-action">
  <button id="enterBtn" class="enter-btn"></button>
</div>

</div>


<button class="back-button back-inline" id="backBtn"></button>

<div class="terminal">
  <div class="terminal-header">
    <div class="window-buttons">
      <span class="close"></span>
      <span class="minimize"></span>
      <span class="maximize"></span>
    </div>
    <div class="terminal-title" id="terminalTitle"></div>
  </div>
  <div class="terminal-body" id="terminalBody">
  <div class="terminal-output" id="terminalOutput"></div>
</div>

</div>

<script type="module">

import { loadConfig } from "./core/config.js";
import { STATES, PHASE, setState } from "./core/state.js";
import { reseedWorld, randFloat, getSeed } from "./core/random.js";
import { initMatrixState } from "./engines/matrix.js";
import { resolveVisitorIP, getVisitorIP, getHostLabel, isIPResolved } from "./core/ip.js";
import { generatePolicyDecision, getPolicyDecision } from "./core/policy.js";
import { applyTheme, getThemeForGroup, getThemePalette } from "./core/theme.js";

;(async () => {

let hasBootedOnce = false;
let CONFIG = {};
let ACTIVE_REGION = "world";

CONFIG = await loadConfig({ basePath: "./data", cache: "no-store" });

document.body.style.overflow = "auto";

/* ================= CONFIG BINDINGS ================= */

const {
  GEO_RESTRICTED_COUNTRIES = [],

  GROUP_WEIGHTS,
  GROUP_LABELS,
  UI_TEXT,
  FLAG_THEMES,

  WEIRD_NAMES,
  FIRST_NAMES,
  LAST_NAMES,
  ASCII_FIGURES,

  MIGRATION_ENABLED = false,
  MIGRATION_CHANCE = 0,
  MIGRATION_MATRIX = {},

  POLICY_RESULTS
} = CONFIG;

// ===== TITLE =====
let titleLogLines = [];

function generateTitleLogs() {

  const base = new Date();

  function pad(n){ return n.toString().padStart(2,"0"); }

  function format(d){
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ` +
           `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

titleLogLines = [];

const events = [
  `nginx: connection from ${getVisitorIP()} accepted`,
  `http: GET / → access control engaged`,
  `auth-module: request context received`,
  `authz: evaluation pending (rbac)`,];

for (let i = 0; i < events.length; i++) {
  const d = new Date(base.getTime() + (i * 1000));
  titleLogLines.push(`[${format(d)}] ${events[i]}`);
}
}

function getTitleText() {
  return `

${titleLogLines.join("\n")}
`;
}

// ===== LOG BUFFER  =====
const LOG_BUFFER_SIZE = 50;
const TAIL_LINES = 3;

let accessLogBuffer = []; // [{ text: "...", color: "#rrggbb" }]

function pushAccessLog(entry) {
  // entry = { text, color }
  accessLogBuffer.push(entry);
  if (accessLogBuffer.length > LOG_BUFFER_SIZE) {
    accessLogBuffer.shift();
  }
}

function getTailLines(n = TAIL_LINES) {
  return accessLogBuffer.slice(-n);
}

/* ================= MATRIX CORE ================= */

const canvas = document.getElementById("matrix");
const ctx = canvas.getContext("2d");
const terminalElement = document.querySelector(".terminal");

const curtainChars = 
"abcdefghijklmnopqrstuvwxyz" +
"ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
"0123456789" +
"-_!+%$#@<>?/()*&";

const matrixChars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" +
"アイウエオカキクケコサシスセソタチツテトナニヌネノ" +
"ハヒフヘホマミムメモヤユヨラリルレロワヲン" +
"一二三四五六七八九十百千万零" +
"%$#@<>?/\\|[]{}()*&^";

let matrixFontSize  = window.innerWidth > 1800 ? 26 : 18;
let curtainFontSize = window.innerWidth > 1800 ? 20 : 14;

let LOOP_DURATION = 45000;

const trailSpacing = 20;

const CURTAIN_BLOCK_WIDTH = 12;
const CURTAIN_GAP_WIDTH   = 4.5;

/* gordijn spacing */
const curtainLineHeight    = curtainFontSize * 0.55;
const curtainColumnSpacing = curtainFontSize * 0.55;

let curtainColumns = 0;
let matrixColumns  = 0;

let drops = [];
let stacks = [];
let curtainGrid = [];
let curtainOffset = 0;
let blackoutStart = 0;

let speeds = [];
let maxLengths = [];
let spawnRates = [];
let drift = [];
let driftOffset = [];

let curtainSpeed = 260;
const acceleration = 700;
const curtainDepth = 4;

const curtainPauseDuration = 3000;
let curtainPauseStart = 0;

let CAPTURED_PASSWORD = null;

let lastTime = 0;
let forceSpike = 0;
let glitchActive = false;
let glitchBursts = 0;
let glitchEnd = 0;
let nextGlitchTime = 0;

let terminalGlitchActive = false;
let terminalGlitchEnd = 0;
let terminalNextGlitch = 0;
let terminalGlitchBursts = 0;
let terminalPhaseStarted = false;

let animationId = null;
let experienceStart = 0;
let pausedAt = 0;

let rollingSession = "";
let rollingStartTime = 0;
let rollingDone = false;
let rollingTriggered = false;

let finalSessionId = "";

let terminalStarted = false;
let terminalRunning = false;

async function startTerminalSequence() {

if (!isIPResolved()) {
await resolveVisitorIP();
}

generateTitleLogs();

terminalElement.classList.add("open");

document.getElementById("terminalTitle").textContent =
  `Terminal-${SITE_USER}@${getVisitorIP()}:~`;

await new Promise(r => requestAnimationFrame(r));

runTerminal();
}

const BASE_DOMAIN = "sterkbijziekte.nl";
const FULL_DOMAIN = "https://sterkbijziekte.nl";
const IP_ADDRESS = "2a02:2350:5:10f:804f:7eb:3c1c:131b";

let LAST_PROTOCOL = "HTTP/1.1";

/* ===== NORMALIZE + BLOCKLIST ===== */

function normalize(str){
  return str.toLowerCase().replace(/\s+/g, "");
}

/*block users*/
const BLOCKED = [
/*    normalize("voornaam.achternaam"), */
];

function generateSessionProfile() {

  const profiles = {
    residential: 60,
    datacenter: 25,
    scripted: 15
  };

  const type = pickFromWeights(profiles);

  const profile = { type };

  if (type === "residential") {
    profile.usernameStyle = "normal";
    profile.protocolBias = "http2";
    profile.latencyBase = 40;
    profile.requestPattern = "human";
  }

  if (type === "datacenter") {
    profile.usernameStyle = "mixed";
    profile.protocolBias = "http1";
    profile.latencyBase = 15;
    profile.requestPattern = "scan";
  }

  if (type === "scripted") {
    profile.usernameStyle = "weird-heavy";
    profile.protocolBias = "http1";
    profile.latencyBase = 5;
    profile.requestPattern = "burst";
  }

  return profile;
}

/* ===== WEIRD USERNAME ===== */

function generateWeirdUsername(group) {
  const weirdPool = WEIRD_NAMES[group] || [];
  if (!weirdPool.length) return null;

  const base = weirdPool[Math.floor(randFloat() * weirdPool.length)];
  let username = base;

  // Suffix verplicht: kies jaar vs digits
  const useYear = randFloat() < 0.60;

  if (useYear) {
    const year = 1968 + Math.floor(randFloat() * 58);
const sep = randFloat() < 0.50 ? "_" : ".";   
    username += sep + year;
  } else {
    const digits = (randFloat() < 0.65)
      ? (10 + Math.floor(randFloat() * 90))     // 10–99
      : Math.floor(randFloat() * 9999);         // 0–9998
    username += digits;
  }

  return { username: username.toLowerCase(), group };
}

function generateNormalUsername(group) {
  const firstPool = FIRST_NAMES[group] || [];
  const lastPool  = LAST_NAMES[group]  || [];

  if (!firstPool.length) {
    return { username: "unknown", group };
  }

  const first = firstPool[Math.floor(randFloat() * firstPool.length)];
  const includeLast = randFloat() < 0.70 && lastPool.length > 0;

  let username = first;
  let pattern = "first_only"; // label zodat we later suffix rules kunnen toepassen

  if (includeLast) {
    const last = lastPool[Math.floor(randFloat() * lastPool.length)];
    const separators = [".", "_", "-"];
    const sep = separators[Math.floor(randFloat() * separators.length)];

    const patternRoll = randFloat();

    if (patternRoll < 0.45) {
      username = first + sep + last;
      pattern = (sep === ".") ? "first_sep_last_dot"
              : (sep === "-") ? "first_sep_last_dash"
              : "first_sep_last_underscore";
    } else if (patternRoll < 0.65) {
      username = last + sep + first;
      pattern = (sep === ".") ? "last_sep_first_dot"
              : (sep === "-") ? "last_sep_first_dash"
              : "last_sep_first_underscore";
    } else if (patternRoll < 0.85) {
      username = first + last;     // geen separator
      pattern = "firstlast";
    } else {
      username = last + first;     // geen separator
      pattern = "lastfirst";
    }
  } else {
    // first only
    const variantRoll = randFloat();

    if (variantRoll < 0.35) {
      const year = 1950 + Math.floor(randFloat() * 71);
      username += year;
      pattern = "first_year";
      return { username: username.toLowerCase(), group };
    } else if (variantRoll < 0.65) {
      username += Math.floor(randFloat() * 9999);
      pattern = "first_digits";
      return { username: username.toLowerCase(), group };
    } else if (variantRoll < 0.80) {
      const year = 1950 + Math.floor(randFloat() * 71);
      const sep = randFloat() < 0.5 ? "_" : "-";
      username += sep + year;
      pattern = "first_sep_year";
      return { username: username.toLowerCase(), group };
    }

  }

  // ===== SUFFIX RULES =====
  // Verboden suffix bij separator formats met . of - 
  const forbidSuffix =
    pattern === "first_sep_last_dot" ||
    pattern === "last_sep_first_dot" ||
    pattern === "first_sep_last_dash" ||
    pattern === "last_sep_first_dash";

  // Optioneel: ook underscore clean houden 
  // || pattern === "first_sep_last_underscore" ||
  // || pattern === "last_sep_first_underscore";

  if (!forbidSuffix) {
    // “Vaak” suffix bij single-name en concatenated formats
    // - bij first_only: heel vaak suffix
    // - bij firstlast/lastfirst: best vaak suffix
    const suffixChance =
      (pattern === "first_only") ? 0.78 :
      (pattern === "firstlast" || pattern === "lastfirst") ? 0.55 :
      0.30;

    if (randFloat() < suffixChance) {
      // mix jaar vs digits
      if (randFloat() < 0.55) {
        const year = 1968 + Math.floor(randFloat() * 58); // 1968–2025-ish
        username += year;
      } else {
        const digits = (randFloat() < 0.55)
          ? Math.floor(randFloat() * 99)     // 0-98
          : Math.floor(randFloat() * 9999);  // 0-9998
        username += digits;
      }
    }
  }

  return { username: username.toLowerCase(), group };
}

/* ===== RANDOM USER ===== */

function getRandomUserByGroup(group) {
  const weirdChance = 0.35; // was 0.15

  if (randFloat() < weirdChance){
    const weird = generateWeirdUsername(group);
    if (weird) return weird;
  }
  return generateNormalUsername(group);
}

function getTrafficType(){
  return randFloat() < 0.75 ? "local" : "external";
}

function pickFromWeights(weightObj) {

  const entries = Object.entries(weightObj);
  const total = entries.reduce((sum, [, weight]) => sum + weight, 0);

  let r = randFloat() * total;

  for (const [key, weight] of entries) {
    if (r < weight) return key;
    r -= weight;
  }

  // fallback
  return entries[0][0];
}

function getWeightedGroup() {

  if (ACTIVE_REGION === "world") {
    return pickFromWeights(GROUP_WEIGHTS);
  }

  const regionWeights =
    CONFIG.GROUP_WEIGHTS_BY_REGION?.[ACTIVE_REGION];

  if (regionWeights) {
    return pickFromWeights(regionWeights);
  }

  return pickFromWeights(GROUP_WEIGHTS);
}

function getRandomUser() {
  const group = getWeightedGroup();

  if (SESSION.usernameStyle === "weird-heavy") {
    if (randFloat() < 0.75) return generateWeirdUsername(group) || generateNormalUsername(group); // was 0.6
  }

  if (SESSION.usernameStyle === "mixed") {
    if (randFloat() < 0.45) return generateWeirdUsername(group) || generateNormalUsername(group); // was 0.3
  }

  return getRandomUserByGroup(group);
}

function applyUILanguage(group){

  const ui = UI_TEXT[group] || UI_TEXT["us"];

  const backBtn = document.getElementById("backBtn");
  if (backBtn) backBtn.textContent = ui.back;

  const enterBtn = document.getElementById("enterBtn");
  if (enterBtn) enterBtn.textContent = ui.enter;
}

function deriveToken(session) {
  if (!session) return "";

  // simpele pseudo-hash (visueel logisch, geen echte crypto)
  let hash = 0;
  for (let i = 0; i < session.length; i++) {
    hash = (hash << 5) - hash + session.charCodeAt(i);
    hash |= 0;
  }

  return Math.abs(hash).toString(16).toUpperCase();
}

function pickUsernameGroup(networkGroup) {

  const foreignChance = 0.10;

  if (randFloat() > foreignChance) {
    return networkGroup;
  }

  const groups = Object.keys(GROUP_WEIGHTS)
    .filter(g => g !== networkGroup);

  if (!groups.length) return networkGroup;

  return groups[Math.floor(randFloat() * groups.length)];
}

let NETWORK_GROUP = getWeightedGroup();
let USERNAME_GROUP = pickUsernameGroup(NETWORK_GROUP);

let SITE_USER_OBJ  = getRandomUserByGroup(USERNAME_GROUP);
let SITE_USER = SITE_USER_OBJ.username;

applyUILanguage(NETWORK_GROUP);

function seedAccessLogIfEmpty() {
  if (accessLogBuffer.length) return;

  pushAccessLog(generateOldLog());
  pushAccessLog(generateOldLog());
}

// Intro minimal: direct zichtbaar maken
const intro = document.getElementById("introScreen");
intro.classList.add("ready");

let SESSION = generateSessionProfile();
generatePolicyDecision({
  networkGroup: NETWORK_GROUP,
  session: SESSION,
  geoRestrictedCountries: GEO_RESTRICTED_COUNTRIES,
  policyResults: POLICY_RESULTS,
  randFloat
});

const selectedTheme = getThemeForGroup(NETWORK_GROUP, FLAG_THEMES);
applyTheme(selectedTheme);

/* ================= TIMING CONFIG ================= */

const TIMING = {
  typingSpeed: 16,
  titlePause: 1500,
  hashPause: 2500,
  blackoutDuration: 250,
  introDuration: 700,
  rollingDuration: 900,
  settleDuration: 400,
  curtainPause: 3000
};

/* ===== TITLE STATE ===== */

let typedLength = 0;
let lastTypeTime = 0;
let titleFinished = 0;

/* ===== RANDOM ASCII ===== */

let RANDOM_ASCII =
  ASCII_FIGURES[Math.floor(randFloat() * ASCII_FIGURES.length)];

/* ===== HASH TEXT ===== */

function getHashText() {

  const lines = [
    `Session-ID: ${rollingSession}`,
    `User-ID: ${SITE_USER}`,
    `X-Auth-Token: ${CAPTURED_PASSWORD || ""}`,
    `Geo: ${GROUP_LABELS[NETWORK_GROUP] || NETWORK_GROUP}`
  ];

  lines.push(
    "",
    "Authorization-Engine: RBAC v2.3",
    `Policy-Check: ${getPolicyDecision().status} (${getPolicyDecision().reason})`,
    "",
    "HTTP 403 - ACCESS DENIED",
    "",
    RANDOM_ASCII
  );

  return lines.join("\n");
}

/* ===== HASH STATE ===== */

let hashTypedLength = 0;
let hashLastTypeTime = 0;
let hashFinished = 0;

/* ================= RESIZE ================= */

let introDrops = [];
let introColumns = 0;

function resize() {

  const ratio = window.devicePixelRatio || 1;
  const cssWidth  = window.innerWidth;
  const cssHeight = window.innerHeight;

  canvas.width  = cssWidth  * ratio;
  canvas.height = cssHeight * ratio;

  canvas.style.width  = cssWidth  + "px";
  canvas.style.height = cssHeight + "px";

  ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  ctx.imageSmoothingEnabled = false;

  curtainColumns = Math.floor(cssWidth / curtainColumnSpacing);
  matrixColumns  = Math.floor(cssWidth / matrixFontSize);

  introColumns = Math.max(
    8,
    Math.floor(cssWidth / matrixFontSize)
  );

  const state = initMatrixState({
    introColumns,
    matrixColumns,
    randFloat
  });

  introDrops  = state.introDrops;
  drops       = state.drops;
  stacks      = state.stacks;
  speeds      = state.speeds;
  maxLengths  = state.maxLengths;
  spawnRates  = state.spawnRates;
  drift       = state.drift;
  driftOffset = state.driftOffset;

  const rows = Math.ceil(cssHeight / curtainLineHeight);
  curtainGrid = [];

  for (let c = 0; c < curtainColumns; c++) {

    curtainGrid[c] = [];

    for (let r = 0; r < rows * curtainDepth; r++) {

      curtainGrid[c][r] =
        curtainChars[Math.floor(randFloat() * curtainChars.length)];
    }
  }

  curtainOffset = -cssHeight;
}

/* ===== RESIZE / START ===== */

window.addEventListener("resize", resize);
resize();

/* ================= RENDER ================= */

ctx.shadowBlur = 0;
ctx.shadowColor = "transparent";
ctx.textAlign = "left";

function charAt(col, row, blockIndex) {
  let x =
    (col * 374761393) ^
    (row * 668265263) ^
    (blockIndex * 1442695041) ^
    getSeed();

  x = (x ^ (x >>> 13)) * 1274126177;
  x = x ^ (x >>> 16);

  const idx = (x >>> 0) % curtainChars.length;
  return curtainChars[idx];
}



const TITLE_LINE_HEIGHT = 18;


function captureCurtainPassword() {

  const H = window.innerHeight;
  const rowsOnScreen = Math.ceil(H / curtainLineHeight);

  const blockWidth = CURTAIN_BLOCK_WIDTH;
  const gapWidth   = CURTAIN_GAP_WIDTH;

  const rowOffset = curtainOffset / curtainLineHeight;
  const baseRow   = Math.floor(rowOffset);

  // kies willekeurige zichtbare kolom
  const visibleColumns = [];

  for (let c = 0; c < curtainColumns; c++) {
    const inBlock = (c % (blockWidth + gapWidth)) < blockWidth;
    if (inBlock) visibleColumns.push(c);
  }

  if (!visibleColumns.length) return;

  const chosenCol = visibleColumns[Math.floor(randFloat() * visibleColumns.length)];
  const blockIndex = Math.floor(chosenCol / (blockWidth + gapWidth));

  const midRow = Math.floor(rowsOnScreen / 2);
  const worldRow = baseRow + midRow;

  let password = "";
  for (let i = 0; i < 8; i++) {
    const col = (chosenCol + i) % curtainColumns;
    password += charAt(col, worldRow, blockIndex);
  }

  CAPTURED_PASSWORD = password;
}

function wrapLine(ctx, line, maxWidth) {
  // BELANGRIJK: lege regel blijft een “regel”
  if (line === "") return [""];

  const words = line.split(" ");
  let current = "";
  const wrapped = [];

  for (let w of words) {
    const test = current ? current + " " + w : w;
    if (ctx.measureText(test).width > maxWidth) {
      wrapped.push(current);
      current = w;
    } else {
      current = test;
    }
  }

  // ook als current leeg is (kan gebeuren bij rare input), push dan toch 1 regel
  if (current !== "") wrapped.push(current);
  if (!wrapped.length) return [""];

  return wrapped;
}

function render(timestamp){

  const runtime = experienceStart ? (timestamp - experienceStart) : 0;

if (
  experienceStart &&
  runtime > LOOP_DURATION &&
  PHASE.current === STATES.MATRIX_RUN
) {
  resetExperience();
  experienceStart = performance.now();
}

  if (!lastTime) lastTime = timestamp;

  let delta = (timestamp - lastTime) / 1000;

  if (forceSpike > 0) {
    delta += forceSpike;
    forceSpike = 0;
  }

  lastTime = timestamp;

const palette = getThemePalette();

  /* ===== BACKGROUND ===== */

const isMatrixTrailPhase = PHASE.current  === 200 || PHASE.current  === 300;

if (isMatrixTrailPhase) {
  ctx.fillStyle = "rgba(0,0,0,0.12)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
} else {
  ctx.clearRect(0,0,canvas.width,canvas.height);
}

  ctx.textBaseline = "top";

/* ===== FASE -100 INTRO ===== */

if (PHASE.current === STATES.INTRO) {

  const height = window.innerHeight;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";

  const depthConfig = [
    { speed: 0.006, alpha: 0.15, scale: 0.9 },
    { speed: 0.010, alpha: 0.30, scale: 1.0 },
    { speed: 0.018, alpha: 0.55, scale: 1.1 }
  ];

  for (let d = 0; d < introDrops.length; d++) {

    const layer = introDrops[d];
    const cfg   = depthConfig[d];

    ctx.globalAlpha = cfg.alpha;
    ctx.font = (matrixFontSize * cfg.scale) + 
               "px 'Noto Sans Mono','IBM Plex Mono',monospace";

    for (let i = 0; i < introColumns; i++) {

      const x = i * matrixFontSize;
      const y = layer[i] * matrixFontSize;

      const char =
        matrixChars[Math.floor(randFloat() * matrixChars.length)];

const baseColor = palette[i % palette.length];

const isBlack =
  baseColor.toLowerCase() === "#000000";

if (isBlack) {

  // 1) lift zonder dubbele alpha-vermenigvuldiging
  ctx.save();
  ctx.globalAlpha = 1; 
  ctx.fillStyle = "rgba(200,200,200,0.25)";
  ctx.fillText(char, x, y);
  ctx.restore();

  // 2) echte zwarte laag met diepte-alpha
  ctx.globalAlpha = cfg.alpha;
  ctx.fillStyle = baseColor;
  ctx.fillText(char, x, y);

} else {

  ctx.fillStyle = baseColor;
  ctx.fillText(char, x, y);
}

      layer[i] += cfg.speed;

      if (y > height) {
        layer[i] = randFloat() * -20;
      }
    }
  }

  ctx.globalAlpha = 1;
  requestAnimationFrame(render);
  return;
}

/* ===== FASE -50 TITLE ===== */

if (PHASE.current  === STATES.TITLE) {

  const currentTitle = getTitleText();

  if (!lastTypeTime) lastTypeTime = timestamp;

  if (typedLength < currentTitle.length) {
    if (timestamp - lastTypeTime > TIMING.typingSpeed) {
      typedLength++;
      lastTypeTime = timestamp;
    }
  } else {
    if (!titleFinished) titleFinished = timestamp;
if (timestamp - titleFinished > TIMING.titlePause) {
  setState(STATES.CURTAIN, timestamp);
}
  }

  ctx.fillStyle = "#ffffff";
  ctx.font = "16px monospace";

  const text = currentTitle.substring(0, typedLength);
  const lines = text.split("\n");

  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], 22, 18 + (i * 18));
  }

  if (Math.floor(timestamp / 500) % 2 === 0) {
    const lines = text.split("\n");
const lastLine = lines[lines.length - 1] || "";

const cursorX = 22 + ctx.measureText(lastLine).width;
const cursorY = 18 + ((lines.length - 1) * 18);

ctx.fillRect(cursorX + 4, cursorY, 8, 16);

  }

  requestAnimationFrame(render);
  return;
}

  /* ===== FASE 0 GORDIJN ===== */

  if (PHASE.current  === STATES.CURTAIN) {

    ctx.font = curtainFontSize + "px 'IBM Plex Mono', monospace";
ctx.shadowBlur = 0;
ctx.shadowColor = "transparent";

    const H = window.innerHeight;
    const rowsOnScreen = Math.ceil(H / curtainLineHeight);

    const blockWidth = CURTAIN_BLOCK_WIDTH;
    const gapWidth   = CURTAIN_GAP_WIDTH;

    const rowOffset = curtainOffset / curtainLineHeight;
    const baseRow   = Math.floor(rowOffset);
    const frac      = rowOffset - baseRow;

    const extra = 4;

    for (let c = 0; c < curtainColumns; c++) {

      const blockIndex = Math.floor(c / (blockWidth + gapWidth));
      const inBlock    = (c % (blockWidth + gapWidth)) < blockWidth;
      if (!inBlock) continue;

const x = c * curtainColumnSpacing;
const baseColor = palette[blockIndex % palette.length];
const isBlack = baseColor.toLowerCase() === "#000000";

for (let r = -extra; r < rowsOnScreen + extra; r++) {
  if ((r & 3) !== 0) continue;

  const worldRow = baseRow + r;
  const y = (r + frac) * curtainLineHeight;

  if (y < -curtainFontSize || y > H + curtainFontSize) continue;

  const ch = charAt(c, worldRow, blockIndex);

  // 1) compensatie-laag voor zwart (zodat het zichtbaar blijft)
  if (isBlack) {
    ctx.save();
    ctx.fillStyle = "rgba(200,200,200,0.6)";
    ctx.fillText(ch, Math.floor(x), Math.floor(y));
    ctx.restore();
  }

  // 2) normale laag
  ctx.fillStyle = baseColor;
  ctx.fillText(ch, Math.floor(x), Math.floor(y));
}

    }

    const firstStop = 0;
    const finalStop = H * curtainDepth;

    if (curtainOffset < firstStop) {
      curtainSpeed = Math.min(curtainSpeed + acceleration * delta, 1400);
      curtainOffset += curtainSpeed * delta;
    } else if (!curtainPauseStart) {
  curtainOffset = firstStop;
  curtainPauseStart = timestamp;

  if (!CAPTURED_PASSWORD) {
    captureCurtainPassword();
  }
} else if (timestamp - curtainPauseStart < curtainPauseDuration) {
      // pause
    } else if (curtainOffset < finalStop) {
      curtainSpeed += acceleration * delta;
      curtainOffset += curtainSpeed * delta;
    } else {
      setState(STATES.HASH, timestamp);
      hashTypedLength = 0;
      hashLastTypeTime = 0;
      hashFinished = 0;
      curtainPauseStart = 0;
      curtainSpeed = 50;
rollingDone = false;
rollingTriggered = false;
finalSessionId = Array.from(crypto.getRandomValues(new Uint8Array(12)))
  .map(b => b.toString(16).padStart(2,"0"))
  .join("")
  .slice(0,16);
rollingSession = "";
    }

    requestAnimationFrame(render);
    return;
  }

  /* ===== FASE 50 HASH SCREEN ===== */

if (PHASE.current  === STATES.HASH) {

  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!hashLastTypeTime) hashLastTypeTime = timestamp;

  /* ===== ROLLING ===== */

  const now = performance.now();
  const rollingDuration = 900;
  const settleDuration = 400;

  if (rollingTriggered && !rollingDone) {

    const elapsed = now - rollingStartTime;

    if (elapsed < rollingDuration) {

      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
      rollingSession = "";

      for (let i = 0; i < 16; i++) {
        rollingSession += chars[Math.floor(randFloat() * chars.length)];
      }

    } else {
      rollingSession = finalSessionId;
      rollingDone = true;
    }
  }

const fullHash = getHashText();
const sessionLineIndex = fullHash.indexOf("Session-ID:");

if (!rollingTriggered && hashTypedLength >= sessionLineIndex - 5) {
  rollingTriggered = true;
  rollingStartTime = performance.now();
}

  /* ===== TYPING ===== */

  if (hashTypedLength < fullHash.length) {
    if (timestamp - hashLastTypeTime > TIMING.typingSpeed) {
      hashTypedLength++;
      hashLastTypeTime = timestamp;
    }
  } else {
    if (!hashFinished) hashFinished = timestamp;

    if (timestamp - hashFinished > TIMING.hashPause){
  setState(STATES.BLACKOUT, timestamp);
}
  }

  /* ===== VISIBILITY LOGIC ===== */

  const rawLines = fullHash.split(/\r?\n/);
  let charCounter = 0;
  const visibleLines = [];

  for (const line of rawLines) {

    const lineLength = line.length + 1;

    if (charCounter + lineLength <= hashTypedLength) {
      visibleLines.push(line);
    }
    else if (charCounter < hashTypedLength) {

      if (line.startsWith("Session-ID:")) {
        visibleLines.push(`Session-ID: ${rollingSession}`);
      } else {
        visibleLines.push(line.substring(0, hashTypedLength - charCounter));
      }

      break;
    }
    else {
      break;
    }

    charCounter += lineLength;
  }

  /* ===== RENDER TEXT ===== */

  ctx.fillStyle = "#ffffff";
  ctx.font = "16px monospace";

  const maxWidth = window.innerWidth - 44;
  const lineHeight = 18;
  let y = 18 + (lineHeight * 2);

  for (const line of visibleLines) {

    const wrapped = wrapLine(ctx, line, maxWidth);

    for (const wl of wrapped) {
      if (wl !== "") ctx.fillText(wl, 22, y);
      y += lineHeight;
    }
  }

  requestAnimationFrame(render);
  return;
}

/* ===== FASE 100 BLACKOUT ===== */

if (PHASE.current  === STATES.BLACKOUT) {

  const elapsed = timestamp - blackoutStart;
  const progress = Math.min(elapsed / TIMING.blackoutDuration, 1);

  ctx.fillStyle = `rgba(0,0,0,${progress})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (elapsed < 60) {
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  if (elapsed < 140) {
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(180,40,40,1)";
    const bandY = (elapsed / 140) * canvas.height;
    ctx.fillRect(0, bandY, canvas.width, 8);
    ctx.restore();
  }

if (elapsed >= TIMING.blackoutDuration) {
  setState(STATES.MATRIX_INTRO);
}

  requestAnimationFrame(render);
  return;
}

  ctx.font = matrixFontSize + "px 'Noto Sans Mono', 'IBM Plex Mono', monospace";

  for (let i = 0; i < matrixColumns; i++) {

    const x = (i * matrixFontSize) + driftOffset[i];
    const y = drops[i] * matrixFontSize;
const colColor = palette[i % palette.length];

if (
  PHASE.current === STATES.MATRIX_INTRO &&
  timestamp - PHASE.start > TIMING.introDuration
) {
  setState(STATES.MATRIX_RUN);

  terminalPhaseStarted = true;
  terminalGlitchActive = true;
  terminalGlitchBursts = 2;
  terminalGlitchEnd = timestamp + 50;

  if (!terminalStarted) {
    terminalStarted = true;
    startTerminalSequence();
  }
}

if (PHASE.current  === STATES.MATRIX_INTRO) {

  const depthLayers = [
    { speed: 0.55, alpha: 0.18, scale: 0.85 },
    { speed: 1.0,  alpha: 0.40, scale: 1.0  },
    { speed: 1.9,  alpha: 0.85, scale: 1.12 }
  ];

  const headY = drops[i] * matrixFontSize;

  for (let d = 0; d < depthLayers.length; d++) {

    const layer = depthLayers[d];

    const layerY = headY * layer.speed;

    ctx.font =
      (matrixFontSize * layer.scale) +
      "px 'Noto Sans Mono','IBM Plex Mono',monospace";

    const char =
      matrixChars[Math.floor(randFloat()*matrixChars.length)];

    if (d === depthLayers.length - 1) {

      ctx.fillStyle = "#e6e6e6";
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 12;
      ctx.shadowColor = "rgba(230,230,230,0.9)";
    } else {
      const isBlack = colColor.toLowerCase() === "#000000";

if (isBlack) {
  ctx.fillStyle = "#d0d0d0";  
  ctx.globalAlpha = layer.alpha * 0.7;
} else {
  ctx.fillStyle = colColor;
  ctx.globalAlpha = layer.alpha;
}
      ctx.shadowBlur = 0;
    }

    ctx.fillText(char, x, layerY);
  }

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  drops[i] += 12 * delta;

  if (drops[i] * matrixFontSize > canvas.height) {
    drops[i] = randFloat() * -40;
  }
} else {

      if (randFloat() < spawnRates[i]) {
        stacks[i].unshift(matrixChars[Math.floor(randFloat()*matrixChars.length)]);
      }

      if (stacks[i].length > maxLengths[i]) stacks[i].pop();

      for (let t = 0; t < stacks[i].length; t++) {

        const trailY = y - (t * trailSpacing);
        if (trailY < 0) continue;

        const alpha = 1 - (t / stacks[i].length);

if (t === 0) {

  // head glow
  ctx.fillStyle = "#e6e6e6";
  ctx.globalAlpha = 0.25;

  ctx.shadowBlur = 12;
  ctx.shadowColor = "rgba(230,230,230,0.9)";

} else {

const baseColor = palette[i % palette.length];
const isBlack = baseColor.toLowerCase() === "#000000";

if (isBlack) {

  ctx.save();
  ctx.fillStyle = "rgba(200,200,200," + (alpha * 0.35) + ")";
  ctx.fillText(stacks[i][t], x, trailY);
  ctx.restore();

  // 2) echte zwarte laag erboven
  ctx.fillStyle = baseColor;
  ctx.globalAlpha = alpha * 0.9;

} else {

  ctx.fillStyle = baseColor;
  ctx.globalAlpha = alpha * 0.8;
}

  ctx.shadowBlur = 0;
}



        ctx.fillText(stacks[i][t], x, trailY);
ctx.shadowBlur = 0;
ctx.globalAlpha = 1;

      }

      drops[i] += speeds[i] * 15 * delta;

      if (drops[i] * matrixFontSize > canvas.height + 120) {
        drops[i] = randFloat() * -20;
        stacks[i] = [];
      }
    }
  }


if (PHASE.current === STATES.MATRIX_INTRO) {

  if (!glitchActive && timestamp >= nextGlitchTime) {

    glitchActive = true;

    glitchBursts = randFloat() < 0.4 ? 2 : 1;

    glitchEnd = timestamp + 45;

    nextGlitchTime = timestamp + 900 + randFloat() * 1300;
  }
}

if (glitchActive) {

  if (timestamp >= glitchEnd) {

    glitchBursts--;

    if (glitchBursts > 0) {

      glitchEnd = timestamp + 70; 
      glitchActive = "gap";     
    } else {
      glitchActive = false;
    }
  }

  if (glitchActive === true) {

    ctx.save();

    ctx.globalAlpha = 0.12 + randFloat() * 0.06;
    ctx.globalCompositeOperation = "source-over";

    ctx.fillStyle = randFloat() < 0.5
      ? "rgba(160,30,25,1)"
      : "rgba(190,60,20,1)";

    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.globalAlpha = 0.18;
    const bandY = randFloat() * canvas.height;
    const bandHeight = 4 + randFloat() * 10;
    ctx.fillRect(0, bandY, canvas.width, bandHeight);

    ctx.restore();
  }

  // gap-afhandeling
  if (glitchActive === "gap" && timestamp >= glitchEnd) {
    glitchActive = true;
    glitchEnd = timestamp + 45;
  }
}


/* ===== TERMINAL GLITCH ENGINE ===== */

if (PHASE.current === STATES.MATRIX_RUN) {

  // normale random scheduling
  if (!terminalGlitchActive && timestamp >= terminalNextGlitch) {

    terminalGlitchActive = true;

    // 25% kans op dubbele burst
    terminalGlitchBursts = randFloat() < 0.25 ? 2 : 1;

    terminalGlitchEnd = timestamp + 40;

    // volgende volledig random interval (5–30 sec)
    terminalNextGlitch =
      timestamp + (5000 + randFloat() * 25000);
  }
}

if (terminalGlitchActive) {

  // teken glitch
  ctx.save();

  ctx.globalAlpha = 0.08 + randFloat() * 0.08;
  ctx.fillStyle = "rgba(170,40,30,1)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.globalAlpha = 0.15;
  const bandY = randFloat() * canvas.height;
  ctx.fillRect(0, bandY, canvas.width, 6 + randFloat() * 10);

  ctx.restore();

  // einde burst?
  if (timestamp >= terminalGlitchEnd) {

    terminalGlitchBursts--;

    if (terminalGlitchBursts > 0) {

      // korte tussenruimte bij dubbele burst
      terminalGlitchEnd = timestamp + 60;

    } else {

      terminalGlitchActive = false;
    }
  }
}

  requestAnimationFrame(render);
}

  
/* ================= TERMINAL ================= */

// genereer 2 eerdere logregels
function generateOldLog() {
  const fakeGroup = getWeightedGroup();

  const fakeIP =
    `${Math.floor(randFloat()*255)}.` +
    `${Math.floor(randFloat()*255)}.` +
    `${Math.floor(randFloat()*255)}.` +
    `${Math.floor(randFloat()*255)}`;

  const fakeUserObj = getRandomUserByGroup(fakeGroup);
  const fakeUser = fakeUserObj.username;

  const fakeSize = Math.floor(120 + randFloat()*200);

  const protocol = randFloat() < 0.7 ? "HTTP/1.1" : "HTTP/2";

  const status = 403;

  const countryLabel = GROUP_LABELS[fakeGroup] || fakeGroup;

  const text =
    `${fakeIP} - ${fakeUser} - [${getNginxTimestamp()}] "GET / ${protocol}" ${status} ${fakeSize} "-" "-" "Mozilla/5.0" "${countryLabel}"`;

  const theme = getThemeForGroup(fakeGroup, FLAG_THEMES);

  // 403 => error-kleur
  let logColor = theme.error;

  // voorkom zwart-op-zwart in terminal
  if (logColor.toLowerCase() === "#000000") {
    logColor = theme.secondary;
  }

  return {
    text,
    color: logColor
  };
}

function getNginxTimestamp() {
  const now = new Date();
  const pad = n => n.toString().padStart(2, "0");
  return `${now.getFullYear()}/${pad(now.getMonth()+1)}/${pad(now.getDate())} ` +
         `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
}

function generateCurlLines() {

  const protocol =
  SESSION.protocolBias === "http2"
    ? (randFloat() < 0.7 ? "HTTP/2" : "HTTP/1.1")
    : (randFloat() < 0.8 ? "HTTP/1.1" : "HTTP/2");

  LAST_PROTOCOL = protocol;

    const base = SESSION.latencyBase;
    const latency = (base + randFloat() * 20).toFixed(0);


  return [
    `* Connected to ${FULL_DOMAIN || "unknown"}`,
    `> GET / ${protocol || "HTTP/1.1"}`,
    `> Host: ${FULL_DOMAIN || "unknown"}`,
    `< ${protocol || "HTTP/1.1"} 403`,
    `HTTP 403 - Access Forbidden (${latency}ms)`
  ];
}

function getUserAgent() {
  return navigator.userAgent;
}

function runTerminal(){

  if (terminalRunning) {
    console.warn("Terminal already running");
    return;
  }

  terminalRunning = true;

  const terminalOutput = document.getElementById("terminalOutput");
    const terminalBody   = document.getElementById("terminalBody");

    terminalOutput.innerHTML = "";

  /* ===== LOCAL TIMESTAMP (NL + DST correct) ===== */
  function getLocalTimestamp() {
    const now = new Date();

    return new Intl.DateTimeFormat("sv-SE", {
      timeZone: "Europe/Amsterdam",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    }).format(now).replace(",", "");
  }

  function createPromptLine(){
    const line = document.createElement("div");
    line.innerHTML =
      '<span class="userhost">' + SITE_USER + '@' + getHostLabel() + '</span>'+
      '<span class="colon">:</span>'+
      '<span class="path">~</span>'+
      '<span class="symbol">$ </span>';
    terminalOutput.appendChild(line);
    return line;
  }

function createRootPromptLine(){
  const line = document.createElement("div");
  line.innerHTML =
    '<span class="userhost">root@' + BASE_DOMAIN + '</span>'+
    '<span class="colon">:</span>'+
    '<span class="path">/var/log</span>'+
    '<span class="symbol"># </span>';
  terminalOutput.appendChild(line);
  return line;
}

  function typeOnLine(line,text,callback){

    const cursor = document.createElement("span");
    cursor.className = "cursor";
    line.appendChild(cursor);

    let i = 0;

    function next(){
      if(i < text.length){
        line.insertBefore(
          document.createTextNode(text[i]),
          cursor
        );
        i++;
        terminalBody.scrollTop = terminalBody.scrollHeight;
        setTimeout(next, 18 + randFloat()*25);
      } else {
        cursor.remove();
        if(callback) setTimeout(callback,300);
      }
    }

    next();
  }

  function outputLinesRandom(lines, minDelay, maxDelay, callback){

    let i = 0;

    function next(){
      if(i >= lines.length){
        if(callback) callback();
        return;
      }

      const div = document.createElement("div");
      div.className = lines[i].includes("403")
        ? "error"
        : "output";

      div.textContent = lines[i];
      terminalOutput.appendChild(div);
      terminalBody.scrollTop = terminalBody.scrollHeight;

      i++;

      const delay = minDelay + randFloat() * (maxDelay - minDelay);
      setTimeout(next, delay);
    }

    next();
  }

/* ===== SEQUENCE ===== */

function sleep(ms){
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function typeLine(line, text, speed = 22){
  const cursor = document.createElement("span");
  cursor.className = "cursor";
  line.appendChild(cursor);

  for(let i = 0; i < text.length; i++){
    line.insertBefore(document.createTextNode(text[i]), cursor);
    await sleep(speed);
    terminalBody.scrollTop = terminalBody.scrollHeight;
  }

  cursor.remove();
  await sleep(200);
}

async function printLines(lines, minDelay = 80, maxDelay = 140){
  for (const l of lines) {
    const row = document.createElement("pre");
    row.className = "term-line " + (l.includes("403") ? "error" : "output");
    row.textContent = l;
    terminalOutput.appendChild(row);
    terminalBody.scrollTop = terminalBody.scrollHeight;

    const delay = minDelay + randFloat() * (maxDelay - minDelay);
    await sleep(delay);
  }
}

async function runSequence(){

  // 1) USER CONTEXT
  const firstPrompt = createPromptLine();
  await sleep(200);
  await typeLine(firstPrompt, `ping ${BASE_DOMAIN}`);

  const pingCount = 2 + Math.floor(randFloat() * 9); 
  const pingLines = [`PING ${BASE_DOMAIN} (${IP_ADDRESS}) 56 data bytes`];
  const times = [];

  for (let i = 1; i <= pingCount; i++) {
    const base = SESSION.latencyBase;
    const jitter = (randFloat() * 4 - 2);
    const time = parseFloat((base + jitter).toFixed(1));
    times.push(time);
    pingLines.push(`64 bytes from ${IP_ADDRESS}: icmp_seq=${i} ttl=53 time=${time} ms`);
  }

  const min = Math.min(...times).toFixed(1);
  const max = Math.max(...times).toFixed(1);
  const avg = (times.reduce((a,b)=>a+b,0) / times.length).toFixed(1);
  const variance = times.reduce((a,b)=>a + Math.pow(b - avg, 2), 0) / times.length;
  const mdev = Math.sqrt(variance).toFixed(2);

  pingLines.push("^C");
  pingLines.push(`--- ${BASE_DOMAIN} ping statistics ---`);
  pingLines.push(`${pingCount} packets transmitted, ${pingCount} received, 0% packet loss`);
  pingLines.push(`rtt min/avg/max/mdev = ${min}/${avg}/${max}/${mdev} ms`);

  await printLines(pingLines);

  // 2) CURL
  const secondPrompt = createPromptLine();
  await typeLine(secondPrompt, `curl -v ${FULL_DOMAIN}`);

  const curlLines = generateCurlLines();
  await printLines(curlLines);

// ===== SERVER CONTEXT =====

const rootPrompt = createRootPromptLine();
await sleep(200);

// laat het commando echt typen
await typeLine(rootPrompt, "tail -n 3 access.log");

// Zorg dat er al "history" is zodat tail -n 3 altijd iets heeft
seedAccessLogIfEmpty();

const responseSize = Math.floor(120 + randFloat() * 80);

const tokenPart = CAPTURED_PASSWORD
  ? ` "X-Auth-Token: ${CAPTURED_PASSWORD}"`
  : "";

const sessionPart = finalSessionId
  ? ` "X-Session-ID: ${finalSessionId}"`
  : "";

const logLine =
  `${getVisitorIP()} - ${SITE_USER} - [${getNginxTimestamp()}] "GET / ${LAST_PROTOCOL}" 403 ${responseSize} "-"${tokenPart}${sessionPart} "${getUserAgent()}" "${GROUP_LABELS[NETWORK_GROUP] || NETWORK_GROUP}"`;

// voeg toe aan buffer (persist tussen runs)
pushAccessLog({
  text: logLine,
  color: getComputedStyle(document.documentElement)
    .getPropertyValue("--color-error")
    .trim()
});

// toon echte tail (laatste 3 regels uit buffer)
const tailLines = getTailLines();
await printAccessTail(tailLines);

// nieuwe prompt
const finalPrompt = createRootPromptLine();
const cursor = document.createElement("span");
cursor.className = "cursor";
finalPrompt.appendChild(cursor);
}

async function printAccessTail(lines) {

  for (let i = 0; i < lines.length; i++) {

    const row = document.createElement("pre");
    row.className = "term-line";

    const entry = lines[i];

    if (typeof entry === "string") {
      row.textContent = entry;
      row.style.color = "#ffffff";
    } else {
      row.textContent = entry.text;

      // gebruik altijd entry.color
      row.style.color = entry.color || "#ffffff";
    }

    terminalOutput.appendChild(row);
    terminalBody.scrollTop = terminalBody.scrollHeight;

    const delay = 60 + randFloat() * 80;
    await sleep(delay);
  }
}

// start
runSequence();

}

async function resetExperience() {
    reseedWorld();

  lastTime = 0;

  typedLength = 0;
  lastTypeTime = 0;
  titleFinished = 0;

  hashTypedLength = 0;
  hashLastTypeTime = 0;
  hashFinished = 0;

  curtainPauseStart = 0;
  blackoutStart = 0;

CAPTURED_PASSWORD = null; 
NETWORK_GROUP = getWeightedGroup();

applyUILanguage(NETWORK_GROUP);

SESSION = generateSessionProfile();
generatePolicyDecision({
  networkGroup: NETWORK_GROUP,
  session: SESSION,
  geoRestrictedCountries: GEO_RESTRICTED_COUNTRIES,
  policyResults: POLICY_RESULTS,
  randFloat
});

  glitchActive = false;
  terminalGlitchActive = false;

  terminalStarted = false;
  terminalRunning = false;

  terminalElement.classList.remove("open");
  document.getElementById("terminalOutput").innerHTML = "";
  document.getElementById("terminalTitle").textContent = "";

  USERNAME_GROUP = pickUsernameGroup(NETWORK_GROUP);
SITE_USER_OBJ = getRandomUserByGroup(USERNAME_GROUP);
SITE_USER = SITE_USER_OBJ.username;

  RANDOM_ASCII =
    ASCII_FIGURES[Math.floor(randFloat() * ASCII_FIGURES.length)];

  const theme = getThemeForGroup(NETWORK_GROUP, FLAG_THEMES);
  applyTheme(theme);

  resize();

  const isColdBoot = !hasBootedOnce;
    setState(isColdBoot ? STATES.INTRO : STATES.TITLE);
    experienceStart = performance.now();

    document.getElementById("introScreen").style.display =
      hasBootedOnce ? "none" : "flex";

if (!hasBootedOnce) {
  document.body.style.overflow = "auto";
} else {
  document.body.style.overflow = "hidden";
}

  // async dingen pas NA reset
await resolveVisitorIP();
generateTitleLogs();
}

/* ===== TAB RETURN SPIKE ===== */

document.addEventListener("visibilitychange", () => {

  if (!document.hidden && (PHASE.current  === 200 || PHASE.current  === 300)) {
    forceSpike = 0.12 + randFloat() * 0.15;
  }
});

await resolveVisitorIP();
generateTitleLogs();

setState(STATES.INTRO);   // <-- TOEVOEGEN

animationId = requestAnimationFrame(render);

/* ===== Gedeelde startfunctie ===== */

async function startExperience() {

  document.body.style.overflow = "hidden";
  hasBootedOnce = true;
  document.getElementById("introScreen").style.display = "none";

  // Nieuwe sessie
  NETWORK_GROUP  = getWeightedGroup();
  USERNAME_GROUP = pickUsernameGroup(NETWORK_GROUP);
  SITE_USER_OBJ  = getRandomUserByGroup(USERNAME_GROUP);
  SITE_USER      = SITE_USER_OBJ.username;

  accessLogBuffer = [];
  seedAccessLogIfEmpty();

  applyUILanguage(NETWORK_GROUP);

  SESSION = generateSessionProfile();
  generatePolicyDecision({
  networkGroup: NETWORK_GROUP,
  session: SESSION,
  geoRestrictedCountries: GEO_RESTRICTED_COUNTRIES,
  policyResults: POLICY_RESULTS,
  randFloat
});

  // opnieuw sessieduur bepalen bij reset
  if (SESSION.type === "scripted") {
    LOOP_DURATION = 29000 + randFloat() * 10000;
  }
  else if (SESSION.type === "datacenter") {
    LOOP_DURATION = 30000 + randFloat() * 15000;
  }
  else {
    LOOP_DURATION = 33500 + randFloat() * 15000;
  }

  RANDOM_ASCII =
    ASCII_FIGURES[Math.floor(randFloat() * ASCII_FIGURES.length)];

  const theme = getThemeForGroup(NETWORK_GROUP, FLAG_THEMES);
  applyTheme(theme);

  typedLength = 0;
  lastTypeTime = 0;
  titleFinished = 0;

  // === IP RESOLVE (SINGLE SOURCE) ===
  if (!isIPResolved()) {
    await resolveVisitorIP();
  }

  // fallback als resolve echt mislukt
  if (!getVisitorIP()) {
console.warn("IP unresolved, using fallback");
}

  generateTitleLogs();

  experienceStart = performance.now();
  setState(STATES.TITLE);
}

/* ===== BACK BUTTON ===== */

const backBtn = document.getElementById("backBtn");

backBtn.addEventListener("click", () => {
  if (history.length > 1) {
    history.back();
  } else {
    window.location.href = "/";
  }
});

/* ===== ENTER BUTTON ===== */

const enterBtn = document.getElementById("enterBtn");

if (enterBtn) {
  enterBtn.addEventListener("click", () => {
    startExperience();
  });
}

})();
</script>

</body>
</html>


